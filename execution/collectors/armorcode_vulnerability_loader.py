#!/usr/bin/env python3
"""
ArmorCode Vulnerability Detail Loader

Fetches individual vulnerability details from ArmorCode GraphQL API.
Extends armorcode_loader.py with detailed vulnerability queries.

Usage:
    from execution.collectors.armorcode_vulnerability_loader import ArmorCodeVulnerabilityLoader

    loader = ArmorCodeVulnerabilityLoader()
    vulnerabilities = loader.load_vulnerabilities_for_products(['Product1', 'Product2'])
"""

import os
from dataclasses import dataclass
from datetime import datetime

from dotenv import load_dotenv

from execution.http_client import post
from execution.secure_config import get_config
from execution.utils.datetime_utils import parse_ado_timestamp

load_dotenv()


@dataclass
class VulnerabilityDetail:
    """Individual vulnerability details from ArmorCode"""

    id: str
    title: str
    description: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    status: str  # OPEN, CONFIRMED, etc.
    created_at: str
    product: str
    age_days: int

    @property
    def is_critical(self) -> bool:
        """Check if vulnerability is critical"""
        return self.severity == "CRITICAL"

    @property
    def is_high(self) -> bool:
        """Check if vulnerability is high severity"""
        return self.severity == "HIGH"

    @property
    def is_critical_or_high(self) -> bool:
        """Check if vulnerability is critical or high"""
        return self.severity in ["CRITICAL", "HIGH"]


class ArmorCodeVulnerabilityLoader:
    """
    Loads detailed vulnerability information from ArmorCode GraphQL API.
    """

    api_key: str | None
    base_url: str | None
    graphql_url: str | None

    def __init__(self):
        """Initialize with ArmorCode config"""
        config = get_config()
        try:
            armorcode_config = config.get_armorcode_config()
            self.api_key = armorcode_config.api_key
            self.base_url = armorcode_config.base_url
        except Exception as e:
            print(f"[WARNING] ArmorCode config not available: {e}")
            self.api_key = None
            self.base_url = None

        self.graphql_url = f"{self.base_url.rstrip('/')}/api/graphql" if self.base_url else None

    def get_product_ids(self, product_names: list[str]) -> dict[str, str]:
        """
        Get product IDs for specified product names via GraphQL.

        Args:
            product_names: List of product names to look up

        Returns:
            Dictionary mapping product names to IDs
        """
        if not self.api_key or not self.graphql_url:
            print("[WARNING] ArmorCode API not configured")
            return {}

        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}

        all_products = []

        # Fetch all pages of products
        for page in range(1, 10):  # Max 10 pages
            query = f"""
            {{
              products(page: {page}, size: 100) {{
                products {{
                  id
                  name
                }}
                pageInfo {{
                  hasNext
                }}
              }}
            }}
            """

            try:
                response = post(self.graphql_url, headers=headers, json={"query": query}, timeout=60)
                if response.status_code == 200:
                    data = response.json()
                    if "data" in data and "products" in data["data"]:
                        result = data["data"]["products"]
                        products = result.get("products", [])
                        all_products.extend(products)

                        if not result.get("pageInfo", {}).get("hasNext", False):
                            break
            except Exception as e:
                print(f"[WARNING] Error fetching products page {page}: {e}")
                break

        # Map product names to IDs
        product_map = {p["name"]: p["id"] for p in all_products}
        print(f"[INFO] Mapped {len(product_map)} products to IDs")

        return product_map

    def load_vulnerabilities_for_products(self, product_names: list[str]) -> list[VulnerabilityDetail]:
        """
        Load vulnerability details for specified products.

        Args:
            product_names: List of product names

        Returns:
            List of VulnerabilityDetail objects

        Example:
            loader = ArmorCodeVulnerabilityLoader()
            vulns = loader.load_vulnerabilities_for_products(['Product1', 'Product2'])
            critical = [v for v in vulns if v.is_critical]
        """
        if not self.api_key or not self.graphql_url:
            print("[WARNING] ArmorCode API not configured - cannot fetch vulnerability details")
            return []

        # Get product IDs first
        print(f"[INFO] Fetching product IDs for {len(product_names)} products...")
        product_id_map = self.get_product_ids(product_names)

        if not product_id_map:
            print("[WARNING] No product IDs found")
            return []

        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}

        all_vulnerabilities = []

        # Query findings for each product
        for product_name in product_names:
            if product_name not in product_id_map:
                print(f"[WARNING] Product not found in ArmorCode: {product_name}")
                continue

            product_id = product_id_map[product_name]
            print(f"[INFO] Querying findings for: {product_name}")

            page = 1
            has_next = True

            while has_next:
                # GraphQL query with filters for OPEN vulnerabilities (all severities)
                query = f"""
                {{
                  findings(
                    page: {page}
                    size: 100
                    findingFilter: {{
                      product: [{product_id}]
                      status: ["OPEN", "CONFIRMED"]
                    }}
                  ) {{
                    findings {{
                      id
                      title
                      description
                      severity
                      status
                      createdAt
                    }}
                    pageInfo {{
                      hasNext
                      totalElements
                    }}
                  }}
                }}
                """

                try:
                    response = post(self.graphql_url, headers=headers, json={"query": query}, timeout=60)

                    if response.status_code == 200:
                        data = response.json()

                        if "errors" in data:
                            print(f"  [ERROR] GraphQL error: {data['errors']}")
                            break

                        if "data" in data and "findings" in data["data"]:
                            result = data["data"]["findings"]
                            findings = result.get("findings", [])

                            # Convert to VulnerabilityDetail objects
                            for finding in findings:
                                created_at = finding.get("createdAt", "")
                                age_days = self._calculate_age_days(created_at)

                                vuln = VulnerabilityDetail(
                                    id=finding.get("id", ""),
                                    title=finding.get("title", ""),
                                    description=finding.get("description", ""),
                                    severity=finding.get("severity", ""),
                                    status=finding.get("status", ""),
                                    created_at=created_at,
                                    product=product_name,
                                    age_days=age_days,
                                )
                                all_vulnerabilities.append(vuln)

                            print(f"  Found {len(findings)} vulnerabilities (page {page})")

                            # Check if there are more pages
                            has_next = result.get("pageInfo", {}).get("hasNext", False)
                            page += 1
                        else:
                            print("  [WARNING] Unexpected response structure")
                            break
                    else:
                        print(f"  [ERROR] HTTP {response.status_code}")
                        break

                except Exception as e:
                    print(f"  [ERROR] Query failed: {e}")
                    break

        print(f"[SUCCESS] Retrieved {len(all_vulnerabilities)} vulnerability details")
        return all_vulnerabilities

    def _calculate_age_days(self, created_at: str) -> int:
        """Calculate age in days from created_at timestamp"""
        if not created_at:
            return 0

        try:
            # Parse ArmorCode format: "Wed Dec 24 16:07:49 UTC 2025"
            created_date = datetime.strptime(created_at, "%a %b %d %H:%M:%S UTC %Y")
            age = datetime.now() - created_date
            return age.days
        except ValueError:
            # Try ISO format fallback (e.g., "2024-01-15T10:30:00Z")
            try:
                created_date = parse_ado_timestamp(created_at)
                if created_date:
                    age = datetime.now() - created_date.replace(tzinfo=None)
                    return age.days
                return 0
            except Exception as e:
                print(f"[WARN] Failed to parse date '{created_at}': {e}")
                return 0

    def group_by_product(self, vulnerabilities: list[VulnerabilityDetail]) -> dict[str, list[VulnerabilityDetail]]:
        """
        Group vulnerabilities by product name.

        Args:
            vulnerabilities: List of VulnerabilityDetail objects

        Returns:
            Dictionary mapping product names to vulnerability lists
        """
        grouped: dict[str, list[VulnerabilityDetail]] = {}

        for vuln in vulnerabilities:
            if vuln.product not in grouped:
                grouped[vuln.product] = []
            grouped[vuln.product].append(vuln)

        return grouped


# Self-test
if __name__ == "__main__":
    print("ArmorCode Vulnerability Loader - Self Test")
    print("=" * 60)

    loader = ArmorCodeVulnerabilityLoader()

    if not loader.api_key:
        print("[ERROR] ARMORCODE_API_KEY not configured")
        print("Set in .env file:")
        print("  ARMORCODE_API_KEY=your-uuid-key")
        print("  ARMORCODE_BASE_URL=https://app.armorcode.com")
    else:
        print("[OK] ArmorCode API configured")
        print(f"  Base URL: {loader.base_url}")
        print(f"  GraphQL URL: {loader.graphql_url}")

        # Test product ID lookup
        test_products = ["TestProduct"]  # Replace with real product name
        print(f"\nTesting product ID lookup for: {test_products}")
        product_ids = loader.get_product_ids(test_products)
        print(f"  Found {len(product_ids)} product IDs")

        # Test vulnerability loading (if you want to test with real data)
        # vulns = loader.load_vulnerabilities_for_products(test_products)
        # print(f"\nFound {len(vulns)} vulnerabilities")
        # for vuln in vulns[:5]:
        #     print(f"  - {vuln.severity}: {vuln.title[:50]}... ({vuln.age_days} days)")
