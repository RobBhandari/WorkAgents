#!/usr/bin/env python3
"""
ArmorCode Vulnerability Detail Loader

Fetches individual vulnerability details from ArmorCode GraphQL API.
Extends armorcode_loader.py with detailed vulnerability queries.

Usage:
    from execution.collectors.armorcode_vulnerability_loader import ArmorCodeVulnerabilityLoader

    loader = ArmorCodeVulnerabilityLoader()
    vulnerabilities = loader.load_vulnerabilities_for_products(['Product1', 'Product2'])
"""

import os
import time
from dataclasses import dataclass
from datetime import datetime

from dotenv import load_dotenv

from execution.http_client import post
from execution.secure_config import get_config
from execution.utils.datetime_utils import parse_ado_timestamp

load_dotenv()


@dataclass
class VulnerabilityDetail:
    """Individual vulnerability details from ArmorCode"""

    id: str
    title: str
    description: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    status: str  # OPEN, CONFIRMED, etc.
    created_at: str
    product: str
    age_days: int
    environment: str | None = None  # Production, Staging, Development, etc.

    @property
    def is_critical(self) -> bool:
        """Check if vulnerability is critical"""
        return self.severity == "CRITICAL"

    @property
    def is_high(self) -> bool:
        """Check if vulnerability is high severity"""
        return self.severity == "HIGH"

    @property
    def is_critical_or_high(self) -> bool:
        """Check if vulnerability is critical or high"""
        return self.severity in ["CRITICAL", "HIGH"]

    @property
    def is_production(self) -> bool:
        """Check if vulnerability is in production environment"""
        return bool(self.environment and self.environment.upper() == "PRODUCTION")


class ArmorCodeVulnerabilityLoader:
    """
    Loads detailed vulnerability information from ArmorCode GraphQL API.
    """

    api_key: str | None
    base_url: str | None
    graphql_url: str | None

    def __init__(self):
        """Initialize with ArmorCode config"""
        config = get_config()
        try:
            armorcode_config = config.get_armorcode_config()
            self.api_key = armorcode_config.api_key
            self.base_url = armorcode_config.base_url
        except Exception as e:
            print(f"[WARNING] ArmorCode config not available: {e}")
            self.api_key = None
            self.base_url = None

        self.graphql_url = f"{self.base_url.rstrip('/')}/api/graphql" if self.base_url else None

    def get_product_ids(self, product_names: list[str]) -> dict[str, str]:
        """
        Get product IDs for specified product names via GraphQL.

        Args:
            product_names: List of product names to look up

        Returns:
            Dictionary mapping product names to IDs
        """
        if not self.api_key or not self.graphql_url:
            print("[WARNING] ArmorCode API not configured")
            return {}

        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}

        all_products = []

        # Fetch all pages of products
        for page in range(1, 10):  # Max 10 pages
            query = f"""
            {{
              products(page: {page}, size: 100) {{
                products {{
                  id
                  name
                }}
                pageInfo {{
                  hasNext
                }}
              }}
            }}
            """

            try:
                response = post(self.graphql_url, headers=headers, json={"query": query}, timeout=60)
                if response.status_code == 200:
                    data = response.json()
                    if "data" in data and "products" in data["data"]:
                        result = data["data"]["products"]
                        products = result.get("products", [])
                        all_products.extend(products)

                        if not result.get("pageInfo", {}).get("hasNext", False):
                            break
            except Exception as e:
                print(f"[WARNING] Error fetching products page {page}: {e}")
                break

        # Map product names to IDs
        product_map = {p["name"]: p["id"] for p in all_products}
        print(f"[INFO] Mapped {len(product_map)} products to IDs")

        return product_map

    def load_vulnerabilities_for_products(
        self, product_names: list[str], filter_environment: bool = True
    ) -> list[VulnerabilityDetail]:
        """
        Load vulnerability details for specified products.

        Args:
            product_names: List of product names
            filter_environment: If True, automatically filters by ARMORCODE_ENVIRONMENT
                              from config. If False, returns all environments.
                              Default: True

        Returns:
            List of VulnerabilityDetail objects

        Example:
            loader = ArmorCodeVulnerabilityLoader()
            # Get Production vulnerabilities only (uses ARMORCODE_ENVIRONMENT)
            vulns = loader.load_vulnerabilities_for_products(['Product1', 'Product2'])

            # Get all environments
            all_vulns = loader.load_vulnerabilities_for_products(['Product1'], filter_environment=False)

            critical = [v for v in vulns if v.is_critical]
        """
        if not self.api_key or not self.graphql_url:
            print("[WARNING] ArmorCode API not configured - cannot fetch vulnerability details")
            return []

        # Get product IDs first
        print(f"[INFO] Fetching product IDs for {len(product_names)} products...")
        product_id_map = self.get_product_ids(product_names)

        if not product_id_map:
            print("[WARNING] No product IDs found")
            return []

        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}

        all_vulnerabilities = []

        # Query findings for each product
        for product_name in product_names:
            if product_name not in product_id_map:
                print(f"[WARNING] Product not found in ArmorCode: {product_name}")
                continue

            product_id = product_id_map[product_name]
            print(f"[INFO] Querying findings for: {product_name}")
            time.sleep(1)  # Avoid rate limiting between products

            page = 1
            has_next = True
            retry_count = 0
            max_retries = 3

            while has_next:
                # GraphQL query - Critical and High only (Medium/Low not displayed)
                query = f"""
                {{
                  findings(
                    page: {page}
                    size: 100
                    findingFilter: {{
                      product: [{product_id}]
                      status: ["OPEN", "CONFIRMED"]
                      severity: ["CRITICAL", "HIGH"]
                    }}
                  ) {{
                    findings {{
                      id
                      title
                      description
                      severity
                      status
                      createdAt
                      environment {{
                        name
                        id
                      }}
                    }}
                    pageInfo {{
                      hasNext
                      totalElements
                    }}
                  }}
                }}
                """

                try:
                    response = post(self.graphql_url, headers=headers, json={"query": query}, timeout=60)

                    if response.status_code == 200:
                        data = response.json()

                        if "errors" in data:
                            print(f"  [ERROR] GraphQL error: {data['errors']}")
                            break

                        if "data" in data and "findings" in data["data"]:
                            result = data["data"]["findings"]
                            findings = result.get("findings", [])

                            # Convert to VulnerabilityDetail objects
                            for finding in findings:
                                created_at = finding.get("createdAt", "")
                                age_days = self._calculate_age_days(created_at)

                                # Extract environment name from nested object
                                environment = None
                                if finding.get("environment"):
                                    environment = finding["environment"].get("name")

                                vuln = VulnerabilityDetail(
                                    id=finding.get("id", ""),
                                    title=finding.get("title", ""),
                                    description=finding.get("description", ""),
                                    severity=finding.get("severity", ""),
                                    status=finding.get("status", ""),
                                    created_at=created_at,
                                    product=product_name,
                                    age_days=age_days,
                                    environment=environment,
                                )
                                all_vulnerabilities.append(vuln)

                            print(f"  Found {len(findings)} vulnerabilities (page {page})")

                            # Check if there are more pages
                            has_next = result.get("pageInfo", {}).get("hasNext", False)
                            page += 1
                        else:
                            print("  [WARNING] Unexpected response structure")
                            break
                    elif response.status_code == 429:
                        retry_after = int(response.headers.get("Retry-After", 60))
                        retry_count += 1
                        if retry_count <= max_retries:
                            print(
                                f"  [RATE LIMIT] HTTP 429 - waiting {retry_after}s then retrying ({retry_count}/{max_retries})..."
                            )
                            time.sleep(retry_after)
                        else:
                            print(f"  [ERROR] HTTP 429 - max retries exceeded for {product_name}")
                            break
                    else:
                        print(f"  [ERROR] HTTP {response.status_code}")
                        break

                except Exception as e:
                    print(f"  [ERROR] Query failed: {e}")
                    break

        print(f"[SUCCESS] Retrieved {len(all_vulnerabilities)} vulnerability details")

        # Apply environment filter if requested
        if filter_environment:
            all_vulnerabilities = self.filter_by_environment(all_vulnerabilities)

        return all_vulnerabilities

    def _calculate_age_days(self, created_at: str) -> int:
        """Calculate age in days from created_at timestamp"""
        if not created_at:
            return 0

        try:
            # Parse ArmorCode format: "Wed Dec 24 16:07:49 UTC 2025"
            created_date = datetime.strptime(created_at, "%a %b %d %H:%M:%S UTC %Y")
            age = datetime.now() - created_date
            return age.days
        except ValueError:
            # Try ISO format fallback (e.g., "2024-01-15T10:30:00Z")
            try:
                created_date_parsed = parse_ado_timestamp(created_at)
                if created_date_parsed:
                    age = datetime.now() - created_date_parsed.replace(tzinfo=None)
                    return age.days
                return 0
            except Exception as e:
                print(f"[WARN] Failed to parse date '{created_at}': {e}")
                return 0

    def filter_by_environment(
        self, vulnerabilities: list[VulnerabilityDetail], environment: str | None = None
    ) -> list[VulnerabilityDetail]:
        """
        Filter vulnerabilities by environment.

        Args:
            vulnerabilities: List of VulnerabilityDetail objects
            environment: Environment name to filter by (e.g., "Production", "Staging").
                        If None, uses ARMORCODE_ENVIRONMENT from config.
                        Case-insensitive comparison.

        Returns:
            Filtered list of VulnerabilityDetail objects

        Example:
            loader = ArmorCodeVulnerabilityLoader()
            all_vulns = loader.load_vulnerabilities_for_products(['Product1'])
            prod_vulns = loader.filter_by_environment(all_vulns, "Production")
        """
        # Get environment filter from parameter or config
        if environment is None:
            try:
                config = get_config()
                environment = config.get_optional_env("ARMORCODE_ENVIRONMENT")
            except Exception:
                environment = None

        # If no environment specified, return all
        if not environment:
            print("[INFO] No environment filter specified - returning all vulnerabilities")
            return vulnerabilities

        # Filter by environment (case-insensitive)
        environment_upper = environment.upper()
        filtered = [v for v in vulnerabilities if v.environment and v.environment.upper() == environment_upper]

        print(
            f"[INFO] Filtered {len(vulnerabilities)} vulnerabilities to {len(filtered)} "
            f"for environment: {environment}"
        )

        return filtered

    def group_by_product(self, vulnerabilities: list[VulnerabilityDetail]) -> dict[str, list[VulnerabilityDetail]]:
        """
        Group vulnerabilities by product name.

        Args:
            vulnerabilities: List of VulnerabilityDetail objects

        Returns:
            Dictionary mapping product names to vulnerability lists
        """
        grouped: dict[str, list[VulnerabilityDetail]] = {}

        for vuln in vulnerabilities:
            if vuln.product not in grouped:
                grouped[vuln.product] = []
            grouped[vuln.product].append(vuln)

        return grouped


# Self-test
if __name__ == "__main__":
    print("ArmorCode Vulnerability Loader - Self Test")
    print("=" * 60)

    loader = ArmorCodeVulnerabilityLoader()

    if not loader.api_key:
        print("[ERROR] ARMORCODE_API_KEY not configured")
        print("Set in .env file:")
        print("  ARMORCODE_API_KEY=your-uuid-key")
        print("  ARMORCODE_BASE_URL=https://app.armorcode.com")
    else:
        print("[OK] ArmorCode API configured")
        print(f"  Base URL: {loader.base_url}")
        print(f"  GraphQL URL: {loader.graphql_url}")

        # Test product ID lookup
        test_products = ["TestProduct"]  # Replace with real product name
        print(f"\nTesting product ID lookup for: {test_products}")
        product_ids = loader.get_product_ids(test_products)
        print(f"  Found {len(product_ids)} product IDs")

        # Test vulnerability loading (if you want to test with real data)
        # vulns = loader.load_vulnerabilities_for_products(test_products)
        # print(f"\nFound {len(vulns)} vulnerabilities")
        # for vuln in vulns[:5]:
        #     print(f"  - {vuln.severity}: {vuln.title[:50]}... ({vuln.age_days} days)")
