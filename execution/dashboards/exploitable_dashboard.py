#!/usr/bin/env python3
"""
Exploitable Vulnerabilities Dashboard Generator

Shows exploitable findings (armorcode.aati.inthewild > 0) across all products,
bucketed by source type (CODE / CLOUD / INFRASTRUCTURE).

Reads from: .tmp/observatory/exploitable_history.json (weekly counts)
            .tmp/observatory/exploitable_latest.json  (per-finding details)
Writes to:  .tmp/observatory/dashboards/exploitable_dashboard.html

Usage:
    python execution/dashboards/exploitable_dashboard.py
"""

import json
import logging
from datetime import datetime
from pathlib import Path

from execution.core import get_logger
from execution.dashboards.components.cards import metric_card
from execution.dashboards.renderer import render_dashboard
from execution.domain.exploitable import ExploitableMetrics
from execution.domain.security import BUCKET_ORDER
from execution.framework import get_dashboard_framework

logger = get_logger(__name__)

HISTORY_PATH = Path(".tmp/observatory/exploitable_history.json")
LATEST_PATH = Path(".tmp/observatory/exploitable_latest.json")
OUTPUT_PATH = Path(".tmp/observatory/dashboards/exploitable_dashboard.html")

TOP_N_PER_BUCKET = 50


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _escape_html(text: str) -> str:
    """Escape HTML special characters to prevent XSS."""
    if not text:
        return ""
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&#x27;")
    )


def _generate_bucket_expanded_content(
    findings: list[dict],
    bucket_breakdown: dict[str, dict[str, int]],
) -> str:
    """
    Generate expanded row HTML for a product: bucket rows with nested vuln table.

    Args:
        findings: List of enriched finding dicts from exploitable_latest.json
        bucket_breakdown: Accurate {bucket: {critical, high}} from exploitable_history.json

    Returns:
        HTML string — a detail-section div containing a bucket-summary-table
    """
    # Group findings by bucket
    by_bucket: dict[str, list[dict]] = {b: [] for b in BUCKET_ORDER}
    for f in findings:
        b = f.get("bucket", "Other")
        if b in by_bucket:
            by_bucket[b].append(f)

    thead = (
        "<thead><tr>"
        '<th class="sortable" onclick="sortBucketTable(this)">Severity '
        '<span class="sort-indicator"></span></th>'
        '<th class="sortable" onclick="sortBucketTable(this)">Source '
        '<span class="sort-indicator"></span></th>'
        '<th class="sortable" onclick="sortBucketTable(this)">Status '
        '<span class="sort-indicator"></span></th>'
        '<th class="sortable" data-type="number" onclick="sortBucketTable(this)">Age (Days) '
        '<span class="sort-indicator"></span></th>'
        '<th class="sortable" onclick="sortBucketTable(this)">Title '
        '<span class="sort-indicator"></span></th>'
        '<th class="sortable" onclick="sortBucketTable(this)">ID '
        '<span class="sort-indicator"></span></th>'
        "</tr></thead>"
    )

    table_body = ""
    for bucket_name in BUCKET_ORDER:
        if bucket_name not in bucket_breakdown:
            continue

        counts = bucket_breakdown[bucket_name]
        total = counts.get("critical", 0) + counts.get("high", 0)
        critical = counts.get("critical", 0)
        high = counts.get("high", 0)

        crit_cls = ' class="critical"' if critical > 0 else ""
        high_cls = ' class="high"' if high > 0 else ""

        vulns = by_bucket.get(bucket_name, [])
        if not vulns:
            # Latest snapshot not yet available (collector not run with new version)
            table_body += (
                f'<tr class="bucket-row expandable" onclick="toggleBucketDetail(this)">'
                f'<td><span class="bucket-arrow">&#9658;</span> <strong>{bucket_name}</strong></td>'
                f"<td>{total}</td><td{crit_cls}>{critical}</td><td{high_cls}>{high}</td>"
                f'</tr><tr class="bucket-detail-row" style="display:none;">'
                f'<td colspan="4" class="vuln-table-note">'
                f"&#9888; Run collector to populate finding details.</td></tr>"
            )
            continue

        # Sort: critical first, then age descending (oldest = most urgent)
        vulns_sorted = sorted(
            vulns,
            key=lambda v: (0 if (v.get("severity") or "").upper() == "CRITICAL" else 1, -(v.get("age_days") or 0)),
        )
        displayed = vulns_sorted[:TOP_N_PER_BUCKET]
        fetched_count = len(displayed)

        truncation_note = ""
        if len(vulns_sorted) > TOP_N_PER_BUCKET:
            truncation_note = (
                f'<p class="vuln-table-note">&#9888; Top {TOP_N_PER_BUCKET} of '
                f"{len(vulns_sorted)} findings shown.</p>"
            )

        crit_shown = sum(1 for v in displayed if (v.get("severity") or "").upper() == "CRITICAL")
        high_shown = sum(1 for v in displayed if (v.get("severity") or "").upper() == "HIGH")

        rows = []
        for idx, v in enumerate(displayed):
            sev = (v.get("severity") or "").lower()
            rows.append(
                f'<tr data-severity="{sev}" data-idx="{idx}">'
                f'<td><span class="badge badge-{sev}">{_escape_html(v.get("severity", ""))}</span></td>'
                f'<td class="vuln-source">{_escape_html(v.get("source", ""))}</td>'
                f"<td>{_escape_html(v.get('status', ''))}</td>"
                f"<td>{v.get('age_days', 0)}</td>"
                f"<td>{_escape_html(v.get('title', ''))}</td>"
                f'<td class="vuln-id">{_escape_html(v.get("id", ""))}</td>'
                f"</tr>"
            )

        search_bar = (
            f'<div class="bucket-filter-bar">'
            f'<input type="text" class="bucket-search-input" '
            f'placeholder="Search vulnerabilities..." oninput="filterBucketVulns(this)">'
            f'<div class="bucket-filter-buttons">'
            f'<button class="active" data-sev="all" onclick="filterBucketSeverity(this,\'all\')">'
            f"All ({fetched_count})</button>"
            f'<button data-sev="critical" onclick="filterBucketSeverity(this,\'critical\')">'
            f"Critical ({crit_shown})</button>"
            f'<button data-sev="high" onclick="filterBucketSeverity(this,\'high\')">'
            f"High ({high_shown})</button>"
            f"</div></div>"
        )

        table_body += (
            f'<tr class="bucket-row expandable" onclick="toggleBucketDetail(this)">'
            f'<td><span class="bucket-arrow">&#9658;</span> <strong>{bucket_name}</strong></td>'
            f"<td>{total}</td>"
            f"<td{crit_cls}>{critical}</td>"
            f"<td{high_cls}>{high}</td>"
            f"</tr>"
            f'<tr class="bucket-detail-row" style="display:none;">'
            f'<td colspan="4">{truncation_note}{search_bar}'
            f'<table class="vuln-table">{thead}<tbody>{"".join(rows)}</tbody></table>'
            f"</td></tr>"
        )

    if not table_body:
        table_body = '<tr><td colspan="4" class="no-findings">No exploitable findings</td></tr>'

    return (
        '<div class="detail-section">'
        '<table class="bucket-summary-table">'
        "<thead><tr>"
        "<th>Finding Type</th><th>Total</th><th>Critical</th><th>High</th>"
        "</tr></thead>"
        f"<tbody>{table_body}</tbody>"
        "</table></div>"
    )


# ---------------------------------------------------------------------------
# Stage 1 — Load Data
# ---------------------------------------------------------------------------


def _load_data() -> list[ExploitableMetrics]:
    """
    Load latest week from exploitable_history.json and return per-product metrics.

    Returns:
        List of ExploitableMetrics, one per product (empty list if no history)
    """
    if not HISTORY_PATH.exists():
        logger.warning(f"History file not found: {HISTORY_PATH}")
        return []

    history = json.loads(HISTORY_PATH.read_text(encoding="utf-8"))
    weeks = history.get("weeks", [])
    if not weeks:
        logger.warning("No weeks found in exploitable history")
        return []

    latest = weeks[-1]
    timestamp_str = latest["metrics"].get("collected_at", latest.get("week_date", ""))
    try:
        timestamp = datetime.fromisoformat(timestamp_str)
    except (ValueError, TypeError):
        timestamp = datetime.utcnow()

    metrics = []
    for product, data in latest["metrics"].get("product_breakdown", {}).items():
        metrics.append(ExploitableMetrics.from_json(product, data, timestamp))

    logger.info(f"Loaded {len(metrics)} products from {latest.get('week_date', '?')}")
    return metrics


def _load_latest_findings() -> dict[str, list[dict]]:
    """
    Load per-finding details from exploitable_latest.json (written by collector).

    Returns:
        Dict mapping product_name -> list of finding dicts (empty if file not found)
    """
    if not LATEST_PATH.exists():
        logger.debug(f"No latest findings file: {LATEST_PATH}")
        return {}
    data = json.loads(LATEST_PATH.read_text(encoding="utf-8"))
    return data.get("products", {})


# ---------------------------------------------------------------------------
# Stage 2 — Calculate Summary
# ---------------------------------------------------------------------------


def _calculate_summary(metrics: list[ExploitableMetrics]) -> dict:
    """
    Compute totals and overall status.

    Returns:
        Summary dict with aggregate counts and status
    """
    total_critical = sum(m.critical for m in metrics)
    total_high = sum(m.high for m in metrics)
    products_with_exploitable = sum(1 for m in metrics if m.total > 0)
    any_incomplete = any(not m.high_data_complete for m in metrics)

    if total_critical > 0:
        status = "action"
        status_text = "Action Needed"
    elif total_high > 0:
        status = "caution"
        status_text = "Caution"
    else:
        status = "good"
        status_text = "Good"

    # Dominant bucket across all products
    bucket_totals: dict[str, int] = dict.fromkeys(BUCKET_ORDER, 0)
    for m in metrics:
        for bucket, counts in m.bucket_breakdown.items():
            if bucket in bucket_totals:
                bucket_totals[bucket] += counts.get("critical", 0) + counts.get("high", 0)

    dominant_bucket = (
        max(bucket_totals, key=lambda b: bucket_totals[b]) if any(v > 0 for v in bucket_totals.values()) else "—"
    )

    return {
        "total_exploitable": total_critical + total_high,
        "total_critical": total_critical,
        "total_high": total_high,
        "products_with_exploitable": products_with_exploitable,
        "product_count": len(metrics),
        "status": status,
        "status_text": status_text,
        "dominant_bucket": dominant_bucket,
        "high_data_complete": not any_incomplete,
    }


# ---------------------------------------------------------------------------
# Stage 3 — Build Context
# ---------------------------------------------------------------------------


def _build_summary_cards(summary: dict) -> list[str]:
    """Generate 4 summary metric cards."""
    total = summary["total_exploitable"]
    incomplete_note = "" if summary["high_data_complete"] else " (partial)"

    cards = [
        metric_card(
            title="Exploitable Findings",
            value=str(total) + ("+" if not summary["high_data_complete"] else ""),
            subtitle=f"Critical + High with in-wild exploitation{incomplete_note}",
            css_class="rag-red" if total > 0 else "rag-green",
        ),
        metric_card(
            title="Critical Exploitable",
            value=str(summary["total_critical"]),
            subtitle="Immediate remediation required",
            css_class="rag-red" if summary["total_critical"] > 0 else "rag-green",
        ),
        metric_card(
            title="High Exploitable",
            value=str(summary["total_high"]) + ("+" if not summary["high_data_complete"] else ""),
            subtitle="High severity with exploitation evidence",
            css_class="rag-amber" if summary["total_high"] > 0 else "rag-green",
        ),
        metric_card(
            title="Products Affected",
            value=str(summary["products_with_exploitable"]),
            subtitle=f"of {summary['product_count']} monitored products",
            css_class="rag-amber" if summary["products_with_exploitable"] > 0 else "rag-green",
        ),
    ]
    return cards


def _build_product_rows(
    metrics: list[ExploitableMetrics],
    latest_findings: dict[str, list[dict]] | None = None,
) -> list[dict]:
    """
    Build product row data for the dashboard table.

    Products are sorted: most critical first, then most high, then name.
    Each row includes expanded_html for the 3-level hierarchy view.
    """
    latest = latest_findings or {}
    rows = []
    for m in sorted(
        metrics,
        key=lambda x: (-x.critical, -x.high, x.product.lower()),
    ):
        rows.append(
            {
                "name": m.product,
                "total": m.total,
                "critical": m.critical,
                "high": m.high,
                "high_data_complete": m.high_data_complete,
                "status": m.status,
                "status_class": m.status_class,
                "expanded_html": _generate_bucket_expanded_content(
                    latest.get(m.product, []),
                    m.bucket_breakdown,
                ),
            }
        )
    return rows


def _build_context(metrics: list[ExploitableMetrics], summary: dict) -> dict:
    """
    Stage 3: Build full template context.

    Returns:
        Context dict including framework_css and framework_js (required)
    """
    framework_css, framework_js = get_dashboard_framework(
        header_gradient_start="#667eea",
        header_gradient_end="#764ba2",
        include_table_scroll=True,
        include_expandable_rows=True,
        include_glossary=True,
    )

    latest_findings = _load_latest_findings()

    return {
        "framework_css": framework_css,
        "framework_js": framework_js,
        "generation_date": datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
        "summary_cards": _build_summary_cards(summary),
        "products": _build_product_rows(metrics, latest_findings),
        "summary": summary,
        "show_incomplete_warning": not summary["high_data_complete"],
    }


# ---------------------------------------------------------------------------
# Stage 4 — Render
# ---------------------------------------------------------------------------


def generate_exploitable_dashboard(output_dir: Path | None = None) -> str:
    """
    Generate the Exploitable Vulnerabilities dashboard HTML.

    Args:
        output_dir: Override output directory (default: .tmp/observatory/dashboards/)

    Returns:
        Generated HTML string
    """
    out_path = (output_dir or OUTPUT_PATH.parent) / OUTPUT_PATH.name
    out_path.parent.mkdir(parents=True, exist_ok=True)

    # Stage 1: Load
    metrics = _load_data()

    # Stage 2: Calculate
    summary = _calculate_summary(metrics)

    # Stage 3: Context
    context = _build_context(metrics, summary)

    # Stage 4: Render
    html = render_dashboard("dashboards/exploitable_dashboard.html", context)
    out_path.write_text(html, encoding="utf-8")

    total = summary["total_exploitable"]
    logger.info(f"Generated exploitable dashboard: {out_path} ({total} exploitable findings)")
    return html


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
    generate_exploitable_dashboard()
