#!/usr/bin/env python3
"""
Exploitable Vulnerabilities Dashboard Generator

Shows exploitable findings (armorcode.aati.inthewild > 0) across all products,
bucketed by source type (CODE / CLOUD / INFRASTRUCTURE).

Reads from: .tmp/observatory/exploitable_history.json
Writes to:  .tmp/observatory/dashboards/exploitable_dashboard.html

Usage:
    python execution/dashboards/exploitable_dashboard.py
"""

import json
import logging
from datetime import datetime
from pathlib import Path

from execution.core import get_logger
from execution.dashboards.components.cards import metric_card
from execution.dashboards.renderer import render_dashboard
from execution.domain.exploitable import ExploitableMetrics
from execution.domain.security import BUCKET_ORDER
from execution.framework import get_dashboard_framework

logger = get_logger(__name__)

HISTORY_PATH = Path(".tmp/observatory/exploitable_history.json")
OUTPUT_PATH = Path(".tmp/observatory/dashboards/exploitable_dashboard.html")


# ---------------------------------------------------------------------------
# Stage 1 — Load Data
# ---------------------------------------------------------------------------


def _load_data() -> list[ExploitableMetrics]:
    """
    Load latest week from exploitable_history.json and return per-product metrics.

    Returns:
        List of ExploitableMetrics, one per product (empty list if no history)
    """
    if not HISTORY_PATH.exists():
        logger.warning(f"History file not found: {HISTORY_PATH}")
        return []

    history = json.loads(HISTORY_PATH.read_text(encoding="utf-8"))
    weeks = history.get("weeks", [])
    if not weeks:
        logger.warning("No weeks found in exploitable history")
        return []

    latest = weeks[-1]
    timestamp_str = latest["metrics"].get("collected_at", latest.get("week_date", ""))
    try:
        timestamp = datetime.fromisoformat(timestamp_str)
    except (ValueError, TypeError):
        timestamp = datetime.utcnow()

    metrics = []
    for product, data in latest["metrics"].get("product_breakdown", {}).items():
        metrics.append(ExploitableMetrics.from_json(product, data, timestamp))

    logger.info(f"Loaded {len(metrics)} products from {latest.get('week_date', '?')}")
    return metrics


# ---------------------------------------------------------------------------
# Stage 2 — Calculate Summary
# ---------------------------------------------------------------------------


def _calculate_summary(metrics: list[ExploitableMetrics]) -> dict:
    """
    Compute totals and overall status.

    Returns:
        Summary dict with aggregate counts and status
    """
    total_critical = sum(m.critical for m in metrics)
    total_high = sum(m.high for m in metrics)
    products_with_exploitable = sum(1 for m in metrics if m.total > 0)
    any_incomplete = any(not m.high_data_complete for m in metrics)

    if total_critical > 0:
        status = "action"
        status_text = "Action Needed"
    elif total_high > 0:
        status = "caution"
        status_text = "Caution"
    else:
        status = "good"
        status_text = "Good"

    # Dominant bucket across all products
    bucket_totals: dict[str, int] = dict.fromkeys(BUCKET_ORDER, 0)
    for m in metrics:
        for bucket, counts in m.bucket_breakdown.items():
            if bucket in bucket_totals:
                bucket_totals[bucket] += counts.get("critical", 0) + counts.get("high", 0)

    dominant_bucket = (
        max(bucket_totals, key=lambda b: bucket_totals[b]) if any(v > 0 for v in bucket_totals.values()) else "—"
    )

    return {
        "total_exploitable": total_critical + total_high,
        "total_critical": total_critical,
        "total_high": total_high,
        "products_with_exploitable": products_with_exploitable,
        "product_count": len(metrics),
        "status": status,
        "status_text": status_text,
        "dominant_bucket": dominant_bucket,
        "high_data_complete": not any_incomplete,
    }


# ---------------------------------------------------------------------------
# Stage 3 — Build Context
# ---------------------------------------------------------------------------


def _build_summary_cards(summary: dict) -> list[str]:
    """Generate 4 summary metric cards."""
    total = summary["total_exploitable"]
    incomplete_note = "" if summary["high_data_complete"] else " (partial)"

    cards = [
        metric_card(
            title="Exploitable Findings",
            value=str(total) + ("+" if not summary["high_data_complete"] else ""),
            subtitle=f"Critical + High with in-wild exploitation{incomplete_note}",
            css_class="rag-red" if total > 0 else "rag-green",
        ),
        metric_card(
            title="Critical Exploitable",
            value=str(summary["total_critical"]),
            subtitle="Immediate remediation required",
            css_class="rag-red" if summary["total_critical"] > 0 else "rag-green",
        ),
        metric_card(
            title="High Exploitable",
            value=str(summary["total_high"]) + ("+" if not summary["high_data_complete"] else ""),
            subtitle="High severity with exploitation evidence",
            css_class="rag-amber" if summary["total_high"] > 0 else "rag-green",
        ),
        metric_card(
            title="Products Affected",
            value=str(summary["products_with_exploitable"]),
            subtitle=f"of {summary['product_count']} monitored products",
            css_class="rag-amber" if summary["products_with_exploitable"] > 0 else "rag-green",
        ),
    ]
    return cards


def _build_product_rows(metrics: list[ExploitableMetrics]) -> list[dict]:
    """
    Build product row data for the dashboard table.

    Products are sorted: most critical first, then most high, then name.
    """
    rows = []
    for m in sorted(
        metrics,
        key=lambda x: (-x.critical, -x.high, x.product.lower()),
    ):
        # Build bucket detail rows
        bucket_rows = []
        for bucket in BUCKET_ORDER:
            counts = m.bucket_breakdown.get(bucket, {"critical": 0, "high": 0})
            crit = counts.get("critical", 0)
            high = counts.get("high", 0)
            if crit + high > 0:
                bucket_rows.append(
                    {
                        "name": bucket,
                        "critical": crit,
                        "high": high,
                        "total": crit + high,
                    }
                )

        rows.append(
            {
                "name": m.product,
                "total": m.total,
                "critical": m.critical,
                "high": m.high,
                "high_data_complete": m.high_data_complete,
                "primary_bucket": m.primary_bucket if m.total > 0 else "—",
                "status": m.status,
                "status_class": m.status_class,
                "bucket_rows": bucket_rows,
                "top_cves": m.top_cves[:10],  # cap at 10 for display
            }
        )
    return rows


def _build_context(metrics: list[ExploitableMetrics], summary: dict) -> dict:
    """
    Stage 3: Build full template context.

    Returns:
        Context dict including framework_css and framework_js (required)
    """
    framework_css, framework_js = get_dashboard_framework(
        header_gradient_start="#667eea",
        header_gradient_end="#764ba2",
        include_table_scroll=True,
        include_expandable_rows=True,
        include_glossary=True,
    )

    return {
        "framework_css": framework_css,
        "framework_js": framework_js,
        "generation_date": datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
        "summary_cards": _build_summary_cards(summary),
        "products": _build_product_rows(metrics),
        "summary": summary,
        "bucket_order": [b for b in BUCKET_ORDER if b != "Other"],
        "show_incomplete_warning": not summary["high_data_complete"],
    }


# ---------------------------------------------------------------------------
# Stage 4 — Render
# ---------------------------------------------------------------------------


def generate_exploitable_dashboard(output_dir: Path | None = None) -> str:
    """
    Generate the Exploitable Vulnerabilities dashboard HTML.

    Args:
        output_dir: Override output directory (default: .tmp/observatory/dashboards/)

    Returns:
        Generated HTML string
    """
    out_path = (output_dir or OUTPUT_PATH.parent) / OUTPUT_PATH.name
    out_path.parent.mkdir(parents=True, exist_ok=True)

    # Stage 1: Load
    metrics = _load_data()

    # Stage 2: Calculate
    summary = _calculate_summary(metrics)

    # Stage 3: Context
    context = _build_context(metrics, summary)

    # Stage 4: Render
    html = render_dashboard("dashboards/exploitable_dashboard.html", context)
    out_path.write_text(html, encoding="utf-8")

    total = summary["total_exploitable"]
    logger.info(f"Generated exploitable dashboard: {out_path} ({total} exploitable findings)")
    return html


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
    generate_exploitable_dashboard()
