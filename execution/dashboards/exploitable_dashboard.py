#!/usr/bin/env python3
"""
Exploitable Vulnerabilities Dashboard Generator

Shows exploitable findings (CISA KEV (isCISAKEV=true)) across all products.

Reads from: .tmp/observatory/exploitable_history.json (weekly counts)
Writes to:  .tmp/observatory/dashboards/exploitable_dashboard.html

Usage:
    python execution/dashboards/exploitable_dashboard.py
"""

import json
import logging
from datetime import datetime
from pathlib import Path

from execution.core import get_logger
from execution.dashboards.components.cards import metric_card
from execution.dashboards.components.charts import sparkline
from execution.dashboards.renderer import render_dashboard
from execution.domain.exploitable import ExploitableMetrics
from execution.framework import get_dashboard_framework

logger = get_logger(__name__)

HISTORY_PATH = Path(".tmp/observatory/exploitable_history.json")
OUTPUT_PATH = Path(".tmp/observatory/dashboards/exploitable_dashboard.html")
ID_MAP_PATH = Path("data/armorcode_id_map.json")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _load_id_map() -> dict[str, str]:
    """
    Load product name → ID mapping from data/armorcode_id_map.json.

    Returns:
        Dict mapping product_name -> product_id

    Raises:
        FileNotFoundError: If the id map file doesn't exist
    """
    if not ID_MAP_PATH.exists():
        raise FileNotFoundError(
            f"{ID_MAP_PATH} not found. " "In CI/CD this is written from the ARMORCODE_ID_MAP secret."
        )
    result: dict[str, str] = json.loads(ID_MAP_PATH.read_text(encoding="utf-8"))
    return result


def _escape_html(text: str) -> str:
    """Escape HTML special characters to prevent XSS."""
    if not text:
        return ""
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&#x27;")
    )


def _build_product_trends(weeks: list[dict]) -> dict[str, list[int]]:
    """Build per-product total counts across all weeks for sparkline rendering."""
    all_products = {p for w in weeks for p in w["metrics"].get("product_breakdown", {})}
    trends: dict[str, list[int]] = {p: [] for p in all_products}
    for w in weeks:
        pb = w["metrics"].get("product_breakdown", {})
        for product in all_products:
            trends[product].append(pb.get(product, {}).get("total", 0))
    return trends


# ---------------------------------------------------------------------------
# Stage 1 — Load Data
# ---------------------------------------------------------------------------


def _load_data() -> tuple[list[ExploitableMetrics], dict[str, list[int]]]:
    """
    Load latest week from exploitable_history.json and return per-product metrics.

    Returns:
        Tuple of (list of ExploitableMetrics, dict of product trend data)
    """
    if not HISTORY_PATH.exists():
        logger.warning(f"History file not found: {HISTORY_PATH}")
        return [], {}

    history = json.loads(HISTORY_PATH.read_text(encoding="utf-8"))
    weeks = history.get("weeks", [])
    if not weeks:
        logger.warning("No weeks found in exploitable history")
        return [], {}

    latest = weeks[-1]
    timestamp_str = latest["metrics"].get("collected_at", latest.get("week_date", ""))
    try:
        timestamp = datetime.fromisoformat(timestamp_str)
    except (ValueError, TypeError):
        timestamp = datetime.utcnow()

    # Load ID map to translate numeric product IDs to human-readable names.
    # Falls back gracefully to showing IDs as-is if the map file is absent.
    try:
        id_map = _load_id_map()
        id_to_name: dict[str, str] = {v: k for k, v in id_map.items()}
    except FileNotFoundError:
        logger.warning("ArmorCode ID map not found; product IDs will be shown as-is")
        id_to_name = {}

    metrics = []
    for product_id, data in latest["metrics"].get("product_breakdown", {}).items():
        product_name = id_to_name.get(product_id, product_id)
        metrics.append(ExploitableMetrics.from_json(product_name, data, timestamp))

    logger.info(f"Loaded {len(metrics)} products from {latest.get('week_date', '?')}")
    raw_trends = _build_product_trends(weeks)
    trends = {id_to_name.get(k, k): v for k, v in raw_trends.items()}
    return metrics, trends


# ---------------------------------------------------------------------------
# Stage 2 — Calculate Summary
# ---------------------------------------------------------------------------


def _calculate_summary(metrics: list[ExploitableMetrics]) -> dict:
    """
    Compute totals and overall status.

    Returns:
        Summary dict with aggregate counts and status
    """
    total_critical = sum(m.critical for m in metrics)
    total_high = sum(m.high for m in metrics)
    total_medium = sum(m.medium for m in metrics)
    products_with_exploitable = sum(1 for m in metrics if m.total > 0)

    if total_critical > 0:
        status = "action"
        status_text = "Action Needed"
    elif total_high > 0 or total_medium > 0:
        status = "caution"
        status_text = "Caution"
    else:
        status = "good"
        status_text = "Good"

    return {
        "total_exploitable": total_critical + total_high + total_medium,
        "total_critical": total_critical,
        "total_high": total_high,
        "total_medium": total_medium,
        "products_with_exploitable": products_with_exploitable,
        "product_count": len(metrics),
        "status": status,
        "status_text": status_text,
        "high_data_complete": True,
    }


# ---------------------------------------------------------------------------
# Stage 3 — Build Context
# ---------------------------------------------------------------------------


def _build_summary_cards(summary: dict) -> list[str]:
    """Generate 5 summary metric cards."""
    total = summary["total_exploitable"]
    cards = [
        metric_card(
            title="Exploitable Findings",
            value=str(total),
            subtitle="Critical + High + Medium (CISA KEV)",
            css_class="rag-red" if total > 0 else "rag-green",
        ),
        metric_card(
            title="Critical Exploitable",
            value=str(summary["total_critical"]),
            subtitle="Immediate remediation required",
            css_class="rag-red" if summary["total_critical"] > 0 else "rag-green",
        ),
        metric_card(
            title="High Exploitable",
            value=str(summary["total_high"]),
            subtitle="High severity with exploitation evidence",
            css_class="rag-amber" if summary["total_high"] > 0 else "rag-green",
        ),
        metric_card(
            title="Medium Exploitable",
            value=str(summary["total_medium"]),
            subtitle="Medium severity with exploitation evidence",
            css_class="rag-amber" if summary["total_medium"] > 0 else "rag-green",
        ),
        metric_card(
            title="Products Affected",
            value=str(summary["products_with_exploitable"]),
            subtitle=f"of {summary['product_count']} monitored products",
            css_class="rag-amber" if summary["products_with_exploitable"] > 0 else "rag-green",
        ),
    ]
    return cards


def _build_product_rows(metrics: list[ExploitableMetrics], trends: dict[str, list[int]]) -> list[dict]:
    """
    Build product row data for the dashboard table.

    Products are sorted: most critical first, then most high, then most medium, then name.
    """
    rows = []
    for m in sorted(
        metrics,
        key=lambda x: (-x.critical, -x.high, -x.medium, x.product.lower()),
    ):
        rows.append(
            {
                "name": m.product,
                "total": m.total,
                "critical": m.critical,
                "high": m.high,
                "medium": m.medium,
                "status": m.status,
                "status_class": m.status_class,
                "trend_sparkline": sparkline(trends.get(m.product, []), width=80, height=24, color="#94a3b8"),
            }
        )
    return rows


def _build_context(metrics: list[ExploitableMetrics], summary: dict, trends: dict[str, list[int]]) -> dict:
    """
    Stage 3: Build full template context.

    Returns:
        Context dict including framework_css and framework_js (required)
    """
    framework_css, framework_js = get_dashboard_framework(
        header_gradient_start="#667eea",
        header_gradient_end="#764ba2",
        include_table_scroll=True,
        include_glossary=True,
    )

    return {
        "framework_css": framework_css,
        "framework_js": framework_js,
        "generation_date": datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
        "summary_cards": _build_summary_cards(summary),
        "products": _build_product_rows(metrics, trends),
        "summary": summary,
    }


# ---------------------------------------------------------------------------
# Stage 4 — Render
# ---------------------------------------------------------------------------


def generate_exploitable_dashboard(output_dir: Path | None = None) -> str:
    """
    Generate the Exploitable Vulnerabilities dashboard HTML.

    Args:
        output_dir: Override output directory (default: .tmp/observatory/dashboards/)

    Returns:
        Generated HTML string
    """
    out_path = (output_dir or OUTPUT_PATH.parent) / OUTPUT_PATH.name
    out_path.parent.mkdir(parents=True, exist_ok=True)

    # Stage 1: Load
    metrics, trends = _load_data()

    # Stage 2: Calculate
    summary = _calculate_summary(metrics)

    # Stage 3: Context
    context = _build_context(metrics, summary, trends)

    # Stage 4: Render
    html = render_dashboard("dashboards/exploitable_dashboard.html", context)
    out_path.write_text(html, encoding="utf-8")

    total = summary["total_exploitable"]
    logger.info(f"Generated exploitable dashboard: {out_path} ({total} exploitable findings)")
    return html


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
    generate_exploitable_dashboard()
