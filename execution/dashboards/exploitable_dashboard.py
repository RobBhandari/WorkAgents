#!/usr/bin/env python3
"""
Exploitable Vulnerabilities Dashboard Generator

Shows exploitable findings (CISA KEV (isCISAKEV=true)) across all products.

Reads from: .tmp/observatory/exploitable_history.json (weekly counts)
Writes to:  .tmp/observatory/dashboards/exploitable_dashboard.html

Usage:
    python execution/dashboards/exploitable_dashboard.py
"""

import json
import logging
from datetime import datetime
from pathlib import Path

from execution.collectors.armorcode_vulnerability_loader import (
    ArmorCodeVulnerabilityLoader,
    VulnerabilityDetail,
)
from execution.core import get_logger
from execution.dashboards.components.cards import metric_card
from execution.dashboards.components.charts import sparkline
from execution.dashboards.renderer import render_dashboard
from execution.domain.exploitable import ExploitableMetrics
from execution.framework import get_dashboard_framework
from execution.secure_config import get_config

logger = get_logger(__name__)

HISTORY_PATH = Path(".tmp/observatory/exploitable_history.json")
OUTPUT_PATH = Path(".tmp/observatory/dashboards/exploitable_dashboard.html")
ID_MAP_PATH = Path("data/armorcode_id_map.json")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _load_id_map() -> dict[str, str]:
    """
    Load product name → ID mapping from data/armorcode_id_map.json.

    Returns:
        Dict mapping product_name -> product_id

    Raises:
        FileNotFoundError: If the id map file doesn't exist
    """
    if not ID_MAP_PATH.exists():
        raise FileNotFoundError(
            f"{ID_MAP_PATH} not found. " "In CI/CD this is written from the ARMORCODE_ID_MAP secret."
        )
    result: dict[str, str] = json.loads(ID_MAP_PATH.read_text(encoding="utf-8"))
    return result


def _escape_html(text: str) -> str:
    """Escape HTML special characters to prevent XSS."""
    if not text:
        return ""
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&#x27;")
    )


_SEV_CSS: dict[str, str] = {
    "CRITICAL": "sev-critical",
    "HIGH": "sev-high",
    "MEDIUM": "sev-medium",
}

_MAX_RECORDS_PER_PRODUCT = 50


def _fetch_product_records(
    metrics: list[ExploitableMetrics],
    id_map: dict[str, str],
) -> dict[str, list[VulnerabilityDetail]]:
    """
    Fetch up to 50 CISA KEV records per product (Critical/High/Medium) for expandable rows.

    Skips products with zero exploitable total. Fails gracefully when the API is
    unavailable (e.g. running locally without credentials) — returns empty dict.

    Args:
        metrics: Per-product exploitable counts from history.
        id_map: Product name → ArmorCode product ID mapping.

    Returns:
        Dict mapping product name → list of VulnerabilityDetail (up to 50 each).
    """
    hierarchy = get_config().get_optional_env("ARMORCODE_HIERARCHY")
    if not hierarchy:
        logger.warning("ARMORCODE_HIERARCHY not set — child records will be empty")
        return {}

    loader = ArmorCodeVulnerabilityLoader()
    if not loader.api_key:
        logger.warning("ArmorCode API not configured — child records will be empty")
        return {}

    records_by_product: dict[str, list[VulnerabilityDetail]] = {}
    for m in metrics:
        if m.total == 0:
            continue  # nothing to fetch for this product
        pid = id_map.get(m.product)
        if not pid:
            logger.warning(f"No ArmorCode ID for product {m.product!r} — skipping")
            continue
        logger.info(f"Fetching CISA KEV records for {m.product} (id={pid})")
        records = loader.fetch_findings_aql(
            hierarchy=hierarchy,
            cisa_kev=True,
            severities=["Critical", "High", "Medium"],
            page_size=_MAX_RECORDS_PER_PRODUCT,
            product_id=pid,
        )
        records_by_product[m.product] = records

    return records_by_product


def _generate_expanded_html(
    records: list[VulnerabilityDetail],
    total_count: int,
) -> str:
    """
    Render an HTML detail table for one product's CISA KEV findings.

    Columns: Title, Severity, Source, Age (days).
    Shows a truncation note when the display cap (50) may have been hit.

    Args:
        records: Up to 50 VulnerabilityDetail objects for this product.
        total_count: Exact total from the history JSON (used in truncation note).

    Returns:
        HTML string (safe to inject with |safe in Jinja2 template).
    """
    if not records:
        return '<p class="no-exploitable">No CISA KEV records returned from API.</p>'

    truncation_note = ""
    if len(records) >= _MAX_RECORDS_PER_PRODUCT:
        truncation_note = (
            f'<p class="truncation-note">'
            f"Showing top {_MAX_RECORDS_PER_PRODUCT} of {total_count} CISA KEV findings."
            f"</p>"
        )

    rows = []
    for v in records:
        sev_upper = v.severity.upper()
        sev_css = _SEV_CSS.get(sev_upper, "")
        title = _escape_html(v.title[:80] + ("…" if len(v.title) > 80 else ""))
        source = _escape_html(v.source or "—")
        rows.append(
            f"<tr>"
            f"<td>{title}</td>"
            f'<td><span class="{sev_css}">{_escape_html(v.severity.capitalize())}</span></td>'
            f"<td>{source}</td>"
            f"<td>{v.age_days}d</td>"
            f"</tr>"
        )

    thead = "<thead><tr>" "<th>Title</th><th>Severity</th><th>Source</th><th>Age</th>" "</tr></thead>"
    table = f'<table class="vuln-table">{thead}' f"<tbody>{''.join(rows)}</tbody></table>"
    return truncation_note + table


def _build_product_trends(weeks: list[dict]) -> dict[str, list[int]]:
    """Build per-product total counts across all weeks for sparkline rendering."""
    all_products = {p for w in weeks for p in w["metrics"].get("product_breakdown", {})}
    trends: dict[str, list[int]] = {p: [] for p in all_products}
    for w in weeks:
        pb = w["metrics"].get("product_breakdown", {})
        for product in all_products:
            trends[product].append(pb.get(product, {}).get("total", 0))
    return trends


# ---------------------------------------------------------------------------
# Stage 1 — Load Data
# ---------------------------------------------------------------------------


def _load_data() -> tuple[list[ExploitableMetrics], dict[str, list[int]], dict[str, str]]:
    """
    Load latest week from exploitable_history.json and return per-product metrics.

    Returns:
        Tuple of (list of ExploitableMetrics, product trend data, name→id map)
        The name→id map is used by _fetch_product_records to look up ArmorCode product IDs.
    """
    if not HISTORY_PATH.exists():
        logger.warning(f"History file not found: {HISTORY_PATH}")
        return [], {}, {}

    history = json.loads(HISTORY_PATH.read_text(encoding="utf-8"))
    weeks = history.get("weeks", [])
    if not weeks:
        logger.warning("No weeks found in exploitable history")
        return [], {}, {}

    latest = weeks[-1]
    timestamp_str = latest["metrics"].get("collected_at", latest.get("week_date", ""))
    try:
        timestamp = datetime.fromisoformat(timestamp_str)
    except (ValueError, TypeError):
        timestamp = datetime.utcnow()

    # Load ID map to translate numeric product IDs to human-readable names.
    # Falls back gracefully to showing IDs as-is if the map file is absent.
    try:
        id_map = _load_id_map()  # name → product_id
        id_to_name: dict[str, str] = {v: k for k, v in id_map.items()}
    except FileNotFoundError:
        logger.warning("ArmorCode ID map not found; product IDs will be shown as-is")
        id_map = {}
        id_to_name = {}

    metrics = []
    for product_id, data in latest["metrics"].get("product_breakdown", {}).items():
        product_name = id_to_name.get(product_id, product_id)
        metrics.append(ExploitableMetrics.from_json(product_name, data, timestamp))

    logger.info(f"Loaded {len(metrics)} products from {latest.get('week_date', '?')}")
    raw_trends = _build_product_trends(weeks)
    trends = {id_to_name.get(k, k): v for k, v in raw_trends.items()}
    return metrics, trends, id_map


# ---------------------------------------------------------------------------
# Stage 2 — Calculate Summary
# ---------------------------------------------------------------------------


def _calculate_summary(metrics: list[ExploitableMetrics]) -> dict:
    """
    Compute totals and overall status.

    Returns:
        Summary dict with aggregate counts and status
    """
    total_critical = sum(m.critical for m in metrics)
    total_high = sum(m.high for m in metrics)
    total_medium = sum(m.medium for m in metrics)
    products_with_exploitable = sum(1 for m in metrics if m.total > 0)

    if total_critical > 0:
        status = "action"
        status_text = "Action Needed"
    elif total_high > 0 or total_medium > 0:
        status = "caution"
        status_text = "Caution"
    else:
        status = "good"
        status_text = "Good"

    return {
        "total_exploitable": total_critical + total_high + total_medium,
        "total_critical": total_critical,
        "total_high": total_high,
        "total_medium": total_medium,
        "products_with_exploitable": products_with_exploitable,
        "product_count": len(metrics),
        "status": status,
        "status_text": status_text,
        "high_data_complete": True,
    }


# ---------------------------------------------------------------------------
# Stage 3 — Build Context
# ---------------------------------------------------------------------------


def _build_summary_cards(summary: dict) -> list[str]:
    """Generate 5 summary metric cards."""
    total = summary["total_exploitable"]
    cards = [
        metric_card(
            title="Exploitable Findings",
            value=str(total),
            subtitle="Critical + High + Medium (CISA KEV)",
            css_class="rag-red" if total > 0 else "rag-green",
        ),
        metric_card(
            title="Critical Exploitable",
            value=str(summary["total_critical"]),
            subtitle="Immediate remediation required",
            css_class="rag-red" if summary["total_critical"] > 0 else "rag-green",
        ),
        metric_card(
            title="High Exploitable",
            value=str(summary["total_high"]),
            subtitle="High severity with exploitation evidence",
            css_class="rag-amber" if summary["total_high"] > 0 else "rag-green",
        ),
        metric_card(
            title="Medium Exploitable",
            value=str(summary["total_medium"]),
            subtitle="Medium severity with exploitation evidence",
            css_class="rag-amber" if summary["total_medium"] > 0 else "rag-green",
        ),
        metric_card(
            title="Products Affected",
            value=str(summary["products_with_exploitable"]),
            subtitle=f"of {summary['product_count']} monitored products",
            css_class="rag-amber" if summary["products_with_exploitable"] > 0 else "rag-green",
        ),
    ]
    return cards


def _build_product_rows(
    metrics: list[ExploitableMetrics],
    trends: dict[str, list[int]],
    records_by_product: dict[str, list[VulnerabilityDetail]],
) -> list[dict]:
    """
    Build product row data for the dashboard table.

    Products are sorted: most critical first, then most high, then most medium, then name.
    Each row includes pre-rendered expanded_html for child records (up to 50 per product).
    """
    rows = []
    for m in sorted(
        metrics,
        key=lambda x: (-x.critical, -x.high, -x.medium, x.product.lower()),
    ):
        product_records = records_by_product.get(m.product, [])
        rows.append(
            {
                "name": m.product,
                "total": m.total,
                "critical": m.critical,
                "high": m.high,
                "medium": m.medium,
                "status": m.status,
                "status_class": m.status_class,
                "trend_sparkline": sparkline(trends.get(m.product, []), width=80, height=24, color="#94a3b8"),
                "has_records": m.total > 0,
                "expanded_html": _generate_expanded_html(product_records, m.total),
            }
        )
    return rows


def _build_context(
    metrics: list[ExploitableMetrics],
    summary: dict,
    trends: dict[str, list[int]],
    records_by_product: dict[str, list[VulnerabilityDetail]],
) -> dict:
    """
    Stage 3: Build full template context.

    Returns:
        Context dict including framework_css and framework_js (required)
    """
    framework_css, framework_js = get_dashboard_framework(
        header_gradient_start="#667eea",
        header_gradient_end="#764ba2",
        include_table_scroll=True,
        include_glossary=True,
    )

    return {
        "framework_css": framework_css,
        "framework_js": framework_js,
        "generation_date": datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
        "summary_cards": _build_summary_cards(summary),
        "products": _build_product_rows(metrics, trends, records_by_product),
        "summary": summary,
    }


# ---------------------------------------------------------------------------
# Stage 4 — Render
# ---------------------------------------------------------------------------


def generate_exploitable_dashboard(output_dir: Path | None = None) -> str:
    """
    Generate the Exploitable Vulnerabilities dashboard HTML.

    Args:
        output_dir: Override output directory (default: .tmp/observatory/dashboards/)

    Returns:
        Generated HTML string
    """
    out_path = (output_dir or OUTPUT_PATH.parent) / OUTPUT_PATH.name
    out_path.parent.mkdir(parents=True, exist_ok=True)

    # Stage 1: Load
    metrics, trends, id_map = _load_data()

    # Stage 2: Calculate
    summary = _calculate_summary(metrics)

    # Stage 1b: Fetch child records (live API call, up to 50 per product)
    records_by_product = _fetch_product_records(metrics, id_map)

    # Stage 3: Context
    context = _build_context(metrics, summary, trends, records_by_product)

    # Stage 4: Render
    html = render_dashboard("dashboards/exploitable_dashboard.html", context)
    out_path.write_text(html, encoding="utf-8")

    total = summary["total_exploitable"]
    logger.info(f"Generated exploitable dashboard: {out_path} ({total} exploitable findings)")
    return html


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
    generate_exploitable_dashboard()
