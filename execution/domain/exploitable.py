"""
Exploitable vulnerability domain models.

Represents vulnerabilities with confirmed CISA KEV (isCISAKEV=true) exploitation signal,
tracked per product with per-severity counts.
"""

from dataclasses import dataclass, field
from datetime import datetime

from execution.domain.metrics import MetricSnapshot


@dataclass(kw_only=True)
class ExploitableMetrics(MetricSnapshot):
    """
    Point-in-time snapshot of exploitable vulnerability counts for one product.

    A finding is considered 'exploitable' when isCISAKEV=true in ArmorCode,
    indicating it appears in the CISA Known Exploited Vulnerabilities catalogue.

    Attributes:
        product: Product name
        critical: Count of exploitable Critical findings
        high: Count of exploitable High findings
        medium: Count of exploitable Medium findings
        bucket_breakdown: Legacy field — kept for backward compatibility (always empty now)
        top_cves: Legacy field — kept for backward compatibility (always empty now)
        high_data_complete: Legacy field — always True now (AQL returns exact counts)
    """

    product: str
    critical: int
    high: int
    medium: int = 0
    # Legacy fields retained for backward compatibility with old history entries
    high_data_complete: bool = True
    bucket_breakdown: dict[str, dict[str, int]] = field(default_factory=dict)
    top_cves: list[str] = field(default_factory=list)

    @property
    def total(self) -> int:
        """Total exploitable findings (critical + high + medium)."""
        return self.critical + self.high + self.medium

    @property
    def status(self) -> str:
        """Human-readable status based on exploitable severity counts."""
        if self.critical > 0:
            return "Action Needed"
        if self.high > 0 or self.medium > 0:
            return "Caution"
        return "Good"

    @property
    def status_class(self) -> str:
        """CSS class for status badge."""
        if self.critical > 0:
            return "action"
        if self.high > 0 or self.medium > 0:
            return "caution"
        return "good"

    @property
    def primary_bucket(self) -> str:
        """Legacy property — returns dominant bucket if available, else 'Other'."""
        if not self.bucket_breakdown:
            return "Other"
        return max(
            self.bucket_breakdown,
            key=lambda b: self.bucket_breakdown[b].get("critical", 0) + self.bucket_breakdown[b].get("high", 0),
        )

    @staticmethod
    def from_json(product: str, data: dict, timestamp: datetime) -> "ExploitableMetrics":
        """
        Factory: build ExploitableMetrics from a product_breakdown entry.

        Args:
            product: Product name
            data: Dict with keys: critical, high, medium (optional), total
            timestamp: Snapshot timestamp

        Returns:
            ExploitableMetrics instance
        """
        return ExploitableMetrics(
            timestamp=timestamp,
            project=product,
            product=product,
            critical=data.get("critical", 0),
            high=data.get("high", 0),
            medium=data.get("medium", 0),
            high_data_complete=data.get("high_data_complete", True),
            bucket_breakdown=data.get("buckets", {}),
            top_cves=data.get("top_cves", []),
        )
