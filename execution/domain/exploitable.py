"""
Exploitable vulnerability domain models.

Represents vulnerabilities with confirmed real-world exploitation signal
(armorcode.aati.inthewild > 0), tracked per product with bucket breakdown.
"""

from dataclasses import dataclass, field
from datetime import datetime

from execution.domain.metrics import MetricSnapshot


@dataclass(kw_only=True)
class ExploitableMetrics(MetricSnapshot):
    """
    Point-in-time snapshot of exploitable vulnerability counts for one product.

    A finding is considered 'exploitable' when the ArmorCode AATI tag
    armorcode.aati.inthewild is greater than zero, indicating confirmed
    in-the-wild exploitation evidence.

    Attributes:
        product: Product name
        critical: Count of exploitable Critical findings
        high: Count of exploitable High findings (may be partial if 10k limit hit)
        high_data_complete: False when ArmorCode's 10k result limit was reached for High
        bucket_breakdown: Counts by source bucket â€” CODE / CLOUD / INFRASTRUCTURE
        top_cves: Unique CVE IDs found across exploitable findings
    """

    product: str
    critical: int
    high: int
    high_data_complete: bool = True
    bucket_breakdown: dict = field(default_factory=dict)
    top_cves: list = field(default_factory=list)

    @property
    def total(self) -> int:
        """Total exploitable findings (critical + high)."""
        return self.critical + self.high

    @property
    def status(self) -> str:
        """Human-readable status based on exploitable critical count."""
        if self.critical > 0:
            return "Action Needed"
        if self.high > 0:
            return "Caution"
        return "Good"

    @property
    def status_class(self) -> str:
        """CSS class for status badge."""
        if self.critical > 0:
            return "action"
        if self.high > 0:
            return "caution"
        return "good"

    @property
    def primary_bucket(self) -> str:
        """Bucket with the highest exploitable count."""
        if not self.bucket_breakdown:
            return "Other"
        return max(
            self.bucket_breakdown,
            key=lambda b: self.bucket_breakdown[b].get("critical", 0) + self.bucket_breakdown[b].get("high", 0),
        )

    @staticmethod
    def from_json(product: str, data: dict, timestamp: datetime) -> "ExploitableMetrics":
        """
        Factory: build ExploitableMetrics from a product_breakdown entry.

        Args:
            product: Product name
            data: Dict with keys: critical, high, high_data_complete, buckets, top_cves
            timestamp: Snapshot timestamp

        Returns:
            ExploitableMetrics instance
        """
        return ExploitableMetrics(
            timestamp=timestamp,
            project=product,
            product=product,
            critical=data.get("critical", 0),
            high=data.get("high", 0),
            high_data_complete=data.get("high_data_complete", True),
            bucket_breakdown=data.get("buckets", {}),
            top_cves=data.get("top_cves", []),
        )
