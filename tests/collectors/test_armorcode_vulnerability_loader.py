"""
Tests for ArmorCode Vulnerability Detail Loader

Comprehensive test coverage for ArmorCode vulnerability loading:
- ArmorCodeVulnerabilityLoader initialization
- get_product_ids() - Product ID mapping with pagination
- load_vulnerabilities_for_products() - Full vulnerability loading pipeline
- _calculate_age_days() - Date parsing and age calculation
- group_by_product() - Vulnerability grouping
- VulnerabilityDetail dataclass properties
- Error handling (API failures, malformed data, missing config)
- Edge cases (empty results, missing fields, pagination)

Run with:
    pytest tests/collectors/test_armorcode_vulnerability_loader.py -v
"""

import json
from datetime import datetime, timedelta
from unittest.mock import Mock, patch

import pytest

from execution.collectors.armorcode_vulnerability_loader import (
    ArmorCodeVulnerabilityLoader,
    VulnerabilityDetail,
)


@pytest.fixture
def mock_config():
    """Mock ArmorCode configuration"""
    config = Mock()
    config.api_key = "test_api_key_12345"
    config.base_url = "https://api.armorcode.com"
    return config


@pytest.fixture
def mock_empty_config():
    """Mock empty ArmorCode configuration for error testing"""
    config = Mock()
    config.get_armorcode_config.side_effect = Exception("Config not available")
    return config


@pytest.fixture
def loader(mock_config):
    """Create ArmorCodeVulnerabilityLoader with mocked config"""
    with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
        mock_get_config.return_value.get_armorcode_config.return_value = mock_config
        return ArmorCodeVulnerabilityLoader()


@pytest.fixture
def loader_no_config(mock_empty_config):
    """Create loader with no config for error handling tests"""
    with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
        mock_get_config.return_value = mock_empty_config
        return ArmorCodeVulnerabilityLoader()


@pytest.fixture
def sample_products_response():
    """Sample products GraphQL response"""
    return {
        "data": {
            "products": {
                "products": [
                    {"id": "1001", "name": "API Gateway"},
                    {"id": "1002", "name": "Web App"},
                    {"id": "1003", "name": "Mobile App"},
                ],
                "pageInfo": {"hasNext": False},
            }
        }
    }


@pytest.fixture
def sample_products_response_multi_page():
    """Sample products response with multiple pages"""
    return [
        {
            "data": {
                "products": {
                    "products": [
                        {"id": "1001", "name": "Product A"},
                        {"id": "1002", "name": "Product B"},
                    ],
                    "pageInfo": {"hasNext": True},
                }
            }
        },
        {
            "data": {
                "products": {
                    "products": [
                        {"id": "1003", "name": "Product C"},
                        {"id": "1004", "name": "Product D"},
                    ],
                    "pageInfo": {"hasNext": False},
                }
            }
        },
    ]


@pytest.fixture
def sample_findings_response():
    """Sample findings GraphQL response"""
    return {
        "data": {
            "findings": {
                "findings": [
                    {
                        "id": "VULN-001",
                        "title": "SQL Injection in API",
                        "description": "SQL injection vulnerability",
                        "severity": "CRITICAL",
                        "status": "OPEN",
                        "createdAt": "Wed Dec 24 16:07:49 UTC 2025",
                    },
                    {
                        "id": "VULN-002",
                        "title": "XSS in Web Form",
                        "description": "Cross-site scripting vulnerability",
                        "severity": "HIGH",
                        "status": "CONFIRMED",
                        "createdAt": "Mon Jan 06 10:30:00 UTC 2026",
                    },
                ],
                "pageInfo": {"hasNext": False, "totalElements": 2},
            }
        }
    }


@pytest.fixture
def sample_findings_multi_page():
    """Sample findings with multiple pages"""
    return [
        {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-001",
                            "title": "Vuln 1",
                            "description": "Description 1",
                            "severity": "CRITICAL",
                            "status": "OPEN",
                            "createdAt": "Wed Dec 24 16:07:49 UTC 2025",
                        }
                    ],
                    "pageInfo": {"hasNext": True, "totalElements": 2},
                }
            }
        },
        {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-002",
                            "title": "Vuln 2",
                            "description": "Description 2",
                            "severity": "HIGH",
                            "status": "OPEN",
                            "createdAt": "Mon Jan 06 10:30:00 UTC 2026",
                        }
                    ],
                    "pageInfo": {"hasNext": False, "totalElements": 2},
                }
            }
        },
    ]


class TestVulnerabilityDetail:
    """Test VulnerabilityDetail dataclass"""

    def test_vulnerability_detail_creation(self):
        """Test creating VulnerabilityDetail instance"""
        vuln = VulnerabilityDetail(
            id="VULN-123",
            title="Test Vulnerability",
            description="Test description",
            severity="CRITICAL",
            status="OPEN",
            created_at="2026-01-01T00:00:00Z",
            product="Test Product",
            age_days=10,
        )

        assert vuln.id == "VULN-123"
        assert vuln.title == "Test Vulnerability"
        assert vuln.severity == "CRITICAL"
        assert vuln.status == "OPEN"
        assert vuln.product == "Test Product"
        assert vuln.age_days == 10

    def test_is_critical_property(self):
        """Test is_critical property"""
        critical_vuln = VulnerabilityDetail(
            id="V1",
            title="T",
            description="D",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )
        high_vuln = VulnerabilityDetail(
            id="V2", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )

        assert critical_vuln.is_critical is True
        assert high_vuln.is_critical is False

    def test_is_high_property(self):
        """Test is_high property"""
        high_vuln = VulnerabilityDetail(
            id="V1", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )
        medium_vuln = VulnerabilityDetail(
            id="V2",
            title="T",
            description="D",
            severity="MEDIUM",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert high_vuln.is_high is True
        assert medium_vuln.is_high is False

    def test_is_critical_or_high_property(self):
        """Test is_critical_or_high property"""
        critical = VulnerabilityDetail(
            id="V1",
            title="T",
            description="D",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )
        high = VulnerabilityDetail(
            id="V2", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )
        medium = VulnerabilityDetail(
            id="V3",
            title="T",
            description="D",
            severity="MEDIUM",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert critical.is_critical_or_high is True
        assert high.is_critical_or_high is True
        assert medium.is_critical_or_high is False


class TestArmorCodeVulnerabilityLoaderInit:
    """Test ArmorCodeVulnerabilityLoader initialization"""

    def test_initialization_success(self, loader, mock_config):
        """Test successful initialization with valid config"""
        assert loader.api_key == "test_api_key_12345"
        assert loader.base_url == "https://api.armorcode.com"
        assert loader.graphql_url == "https://api.armorcode.com/api/graphql"

    def test_initialization_strips_trailing_slash(self):
        """Test that trailing slash is stripped from base URL in graphql_url"""
        config = Mock()
        config.api_key = "test_key"
        config.base_url = "https://api.armorcode.com/"

        with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
            mock_get_config.return_value.get_armorcode_config.return_value = config
            loader = ArmorCodeVulnerabilityLoader()
            # base_url is stored as-is, but graphql_url strips trailing slash
            assert loader.base_url == "https://api.armorcode.com/"
            assert loader.graphql_url == "https://api.armorcode.com/api/graphql"

    def test_initialization_no_config(self, loader_no_config):
        """Test initialization when config is not available"""
        assert loader_no_config.api_key is None
        assert loader_no_config.base_url is None
        assert loader_no_config.graphql_url is None

    @patch("execution.collectors.armorcode_vulnerability_loader.print")
    def test_initialization_logs_warning_on_config_error(self, mock_print):
        """Test that config errors are logged as warnings"""
        with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
            mock_get_config.return_value.get_armorcode_config.side_effect = Exception("Config error")
            loader = ArmorCodeVulnerabilityLoader()

            assert loader.api_key is None
            mock_print.assert_called()
            call_args = str(mock_print.call_args)
            assert "[WARNING]" in call_args
            assert "ArmorCode config not available" in call_args


class TestCalculateAgeDays:
    """Test _calculate_age_days() method"""

    def test_calculate_age_days_armorcode_format(self, loader):
        """Test age calculation with ArmorCode date format"""
        # Create a date 10 days ago
        past_date = datetime.now() - timedelta(days=10)
        date_str = past_date.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 10

    def test_calculate_age_days_iso_format(self, loader):
        """Test age calculation with ISO format fallback"""
        # Create a date 5 days ago
        past_date = datetime.now() - timedelta(days=5)
        date_str = past_date.strftime("%Y-%m-%dT%H:%M:%SZ")

        age = loader._calculate_age_days(date_str)

        assert age == 5

    def test_calculate_age_days_empty_string(self, loader):
        """Test age calculation with empty string"""
        age = loader._calculate_age_days("")

        assert age == 0

    def test_calculate_age_days_invalid_format(self, loader):
        """Test age calculation with invalid date format"""
        age = loader._calculate_age_days("invalid date string")

        assert age == 0

    def test_calculate_age_days_zero_days(self, loader):
        """Test age calculation for today's date"""
        today = datetime.now()
        date_str = today.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 0

    def test_calculate_age_days_recent_vulnerability(self, loader):
        """Test age calculation for recent vulnerability"""
        # 1 day ago
        yesterday = datetime.now() - timedelta(days=1)
        date_str = yesterday.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 1

    def test_calculate_age_days_old_vulnerability(self, loader):
        """Test age calculation for old vulnerability"""
        # 365 days ago
        year_ago = datetime.now() - timedelta(days=365)
        date_str = year_ago.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 365


class TestGroupByProduct:
    """Test group_by_product() method"""

    def test_group_by_product_single_product(self, loader):
        """Test grouping vulnerabilities from single product"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=2,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert len(result) == 1
        assert "Product A" in result
        assert len(result["Product A"]) == 2

    def test_group_by_product_multiple_products(self, loader):
        """Test grouping vulnerabilities from multiple products"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product B",
                age_days=2,
            ),
            VulnerabilityDetail(
                id="V3",
                title="T3",
                description="D3",
                severity="MEDIUM",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=3,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert len(result) == 2
        assert "Product A" in result
        assert "Product B" in result
        assert len(result["Product A"]) == 2
        assert len(result["Product B"]) == 1

    def test_group_by_product_empty_list(self, loader):
        """Test grouping empty vulnerability list"""
        result = loader.group_by_product([])

        assert result == {}

    def test_group_by_product_preserves_order(self, loader):
        """Test that grouping preserves vulnerability order within products"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=2,
            ),
            VulnerabilityDetail(
                id="V3",
                title="T3",
                description="D3",
                severity="MEDIUM",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=3,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert result["Product A"][0].id == "V1"
        assert result["Product A"][1].id == "V2"
        assert result["Product A"][2].id == "V3"


class TestEdgeCases:
    """Test edge cases and unusual scenarios"""

    def test_vulnerability_with_long_description(self):
        """Test vulnerability with very long description"""
        long_desc = "A" * 10000

        vuln = VulnerabilityDetail(
            id="V1",
            title="Test",
            description=long_desc,
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert len(vuln.description) == 10000

    def test_vulnerability_with_unicode_characters(self):
        """Test vulnerability with unicode characters"""
        vuln = VulnerabilityDetail(
            id="V1",
            title="SQL Injection ä¸­æ–‡æµ‹è¯•",
            description="Vulnerability with Ã©mojis ðŸ”’ðŸ”“",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="Productâ„¢",
            age_days=1,
        )

        assert "ä¸­æ–‡æµ‹è¯•" in vuln.title
        assert "Ã©mojis" in vuln.description
        assert "â„¢" in vuln.product


class TestLoadVulnerabilitiesHybrid:
    """Tests for load_vulnerabilities_hybrid() per-bucket fetch logic."""

    def test_fetches_all_sources_per_product(self, loader):
        """
        All 11 sources in SOURCE_BUCKET_MAP get a separate _fetch_product_pages call.
        Detail records are capped at max_per_bucket per source.
        Bucket counts are returned as None â€” computed by the caller via AQL.

        Scenario: product has Prisma Cloud Redlock (CLOUD) and Cortex XDR (INFRA) findings.
        All 11 sources are tried; empty results for sources with no findings are harmless.
        """
        from unittest.mock import patch

        from execution.collectors.armorcode_vulnerability_loader import VulnerabilityDetail

        def make_vuln(source: str, severity: str = "HIGH") -> VulnerabilityDetail:
            return VulnerabilityDetail(
                id=f"id-{source[:3]}",
                title="t",
                description="",
                severity=severity,
                status="OPEN",
                created_at="",
                product="Access Legal",
                age_days=5,
                source=source,
                environment="Production",
            )

        cloud_redlock_vulns = [make_vuln("Prisma Cloud Redlock")] * 29
        infra_cortex_vulns = [make_vuln("Cortex XDR")] * 40
        empty: list = []

        # Side effects for all 11 sources in SOURCE_BUCKET_MAP order:
        # CODE: Mend, SonarQube, Custom-Pentest
        # CLOUD: Prisma Cloud Twistlock, Prisma Cloud Redlock, Prisma Cloud Compute
        # INFRA: Cortex XDR, Tenable Infrastructure, Tenable Vulnerability Management, AppCheck, BitSight
        page_side_effects = [
            (empty, 0),  # Mend (CODE)
            (empty, 0),  # SonarQube (CODE)
            (empty, 0),  # Custom-Pentest (CODE)
            (empty, 0),  # Prisma Cloud Twistlock (CLOUD)
            (cloud_redlock_vulns, 29),  # Prisma Cloud Redlock (CLOUD)
            (empty, 0),  # Prisma Cloud Compute (CLOUD)
            (infra_cortex_vulns, 40),  # Cortex XDR (INFRA)
            (empty, 0),  # Tenable Infrastructure (INFRA)
            (empty, 0),  # Tenable Vulnerability Management (INFRA)
            (empty, 0),  # AppCheck (INFRA)
            (empty, 0),  # BitSight (INFRA)
        ]

        with (
            patch.object(loader, "get_product_ids", return_value={"Access Legal": "pid-42"}, create=True),
            patch.object(loader, "_fetch_product_pages", side_effect=page_side_effects) as mock_pages,
            patch.object(loader, "_count_product_severity", return_value=0),
            patch.object(loader, "filter_by_environment", side_effect=lambda v: v),
        ):
            vulns, bucket_counts, _, _ = loader.load_vulnerabilities_hybrid(
                ["Access Legal"], filter_environment=True, max_per_bucket=50
            )

        # All 11 sources are tried (no pre-filtering by bucket)
        assert mock_pages.call_count == 11
        fetched_sources = [c.kwargs.get("source") or c.args[3] for c in mock_pages.call_args_list]
        assert "Prisma Cloud Redlock" in fetched_sources
        assert "Cortex XDR" in fetched_sources
        assert "Mend" in fetched_sources  # CODE sources now attempted too
        assert "SonarQube" in fetched_sources  # CODE sources now attempted too

        # All 29 CLOUD records are included (â‰¤ 50 cap)
        cloud_result = [v for v in vulns if v.source == "Prisma Cloud Redlock"]
        assert len(cloud_result) == 29

        # Bucket counts are None â€” AQL counts are computed by the caller (security_enhanced.py)
        assert bucket_counts["Access Legal"] is None


class TestCountByBucketAql:
    """Tests for count_by_bucket_aql() method."""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_per_product_counts_for_code_bucket(self, mock_post, loader):
        """CODE bucket AQL returns per-product counts filtered to CODE sources."""
        mock_resp = Mock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "pid-1": {"count": 10},
            "pid-2": {"count": 5},
        }
        mock_post.return_value = mock_resp

        result = loader.count_by_bucket_aql("CODE", "Critical", "access group/legal")

        assert result == {"pid-1": 10, "pid-2": 5}
        # Verify AQL payload includes source filter for CODE sources
        call_kwargs = mock_post.call_args[1]
        payload = call_kwargs["json"]
        aql = payload["filters"]["aqlQuery"][0]
        assert "source IN" in aql
        assert "Mend" in aql
        assert "SonarQube" in aql
        assert "Custom-Pentest" in aql
        assert "environment = Production" in aql
        assert "severity = Critical" in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_per_product_counts_for_cloud_bucket(self, mock_post, loader):
        """CLOUD bucket AQL uses Prisma Cloud sources."""
        mock_resp = Mock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {"pid-3": {"count": 29}}
        mock_post.return_value = mock_resp

        result = loader.count_by_bucket_aql("CLOUD", "High", "access group/legal")

        assert result == {"pid-3": 29}
        call_kwargs = mock_post.call_args[1]
        aql = call_kwargs["json"]["filters"]["aqlQuery"][0]
        assert "Prisma Cloud" in aql
        assert "severity = High" in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_empty_on_http_error(self, mock_post, loader):
        """Returns empty dict on HTTP error."""
        mock_resp = Mock()
        mock_resp.status_code = 500
        mock_resp.text = "Internal Server Error"
        mock_post.return_value = mock_resp

        result = loader.count_by_bucket_aql("CODE", "Critical", "access group/legal")

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_empty_on_network_error(self, mock_post, loader):
        """Returns empty dict on network failure."""
        mock_post.side_effect = Exception("Connection refused")

        result = loader.count_by_bucket_aql("CODE", "Critical", "access group/legal")

        assert result == {}

    def test_returns_empty_when_no_config(self, loader_no_config):
        """Returns empty dict when ArmorCode is not configured."""
        result = loader_no_config.count_by_bucket_aql("CODE", "Critical", "access group/legal")
        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_quotes_sources_with_spaces_and_hyphens(self, mock_post, loader):
        """Source names with spaces or hyphens are quoted in AQL."""
        mock_resp = Mock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {}
        mock_post.return_value = mock_resp

        loader.count_by_bucket_aql("INFRASTRUCTURE", "High", "access group/legal")

        call_kwargs = mock_post.call_args[1]
        aql = call_kwargs["json"]["filters"]["aqlQuery"][0]
        # Cortex XDR has a space â†’ must be quoted
        assert "'Cortex XDR'" in aql
        # AppCheck has no space/hyphen â†’ unquoted
        assert "AppCheck" in aql


# ---------------------------------------------------------------------------
# fetch_findings_aql + _age_from_epoch_ms
# ---------------------------------------------------------------------------


def _aql_record(
    id: str = "7939440927",
    title: str = "CVE-2026-26996 | minimatch",
    severity: str = "HIGH",
    status: str = "CONFIRMED",
    source: str = "Mend",
    product_name: str = "inCase",
    environment_name: str = "Production",
    created_at_ms: int = 1771478352000,
    description: str = "A vulnerability description",
) -> dict:
    """Minimal AQL /user/findings/ record matching the real API shape."""
    return {
        "id": int(id),
        "title": title,
        "severity": severity,
        "status": status,
        "source": source,
        "createdAt": created_at_ms,
        "description": description,
        "product": {"id": 227595, "name": product_name},
        "environment": {"id": 1337433, "name": environment_name},
        "subProduct": {"id": 677117, "name": f"{product_name}-client"},
    }


def _page_response(content: list, last: bool = True, total: int | None = None) -> dict:
    """Minimal Spring Page<T> wrapper."""
    return {
        "content": content,
        "last": last,
        "totalElements": total if total is not None else len(content),
        "pageable": {"pageNumber": 0, "pageSize": len(content)},
    }


class TestFetchFindingsAql:
    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_vulnerability_details(self, mock_post, loader):
        """Maps AQL record fields to VulnerabilityDetail correctly."""
        record = _aql_record(id="123", title="Test vuln", severity="CRITICAL", source="SonarQube")
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([record])))

        results = loader.fetch_findings_aql("access group/legal")

        assert len(results) == 1
        vuln = results[0]
        assert vuln.id == "123"
        assert vuln.title == "Test vuln"
        assert vuln.severity == "CRITICAL"
        assert vuln.source == "SonarQube"
        assert vuln.product == "inCase"
        assert vuln.environment == "Production"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_paginates_until_last(self, mock_post, loader):
        """Fetches multiple pages and stops when last=True."""
        page1 = _page_response([_aql_record(id="1")], last=False, total=2)
        page2 = _page_response([_aql_record(id="2")], last=True, total=2)
        mock_post.return_value = Mock(status_code=200, json=Mock(side_effect=[page1, page2]))

        # page_size=1 so len(content)==page_size â€” only last=True triggers the stop
        results = loader.fetch_findings_aql("access group/legal", page_size=1)

        assert len(results) == 2
        assert mock_post.call_count == 2

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_uses_size_1000_by_default(self, mock_post, loader):
        """Default page_size is 1000."""
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([])))

        loader.fetch_findings_aql("access group/legal")

        payload = mock_post.call_args[1]["json"]
        assert payload["size"] == 1000

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_aql_contains_hierarchy_and_environment(self, mock_post, loader):
        """AQL string contains hierarchy filter and environment filter."""
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([])))

        loader.fetch_findings_aql("access group/legal", environment="Production")

        payload = mock_post.call_args[1]["json"]
        aql = payload["filters"]["aqlQuery"][0]
        assert "armorcode.group:access group/legal" in aql
        assert "environment = Production" in aql
        assert "severity IN (High,Critical)" in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_no_environment_filter_when_none(self, mock_post, loader):
        """Passing environment=None omits the environment clause."""
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([])))

        loader.fetch_findings_aql("access group/legal", environment=None)

        aql = mock_post.call_args[1]["json"]["filters"]["aqlQuery"][0]
        assert "environment" not in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_empty_on_http_error(self, mock_post, loader):
        """Returns empty list when API returns non-200."""
        mock_post.return_value = Mock(status_code=429, text="Too Many Requests")

        results = loader.fetch_findings_aql("access group/legal")

        assert results == []

    def test_returns_empty_when_not_configured(self, loader_no_config):
        """Returns empty list when API key is not configured."""
        results = loader_no_config.fetch_findings_aql("access group/legal")
        assert results == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_age_calculated_from_epoch_ms(self, mock_post, loader):
        """age_days is derived from epoch millisecond createdAt."""
        from datetime import datetime, timedelta

        one_week_ago = datetime.now() - timedelta(days=7)
        epoch_ms = int(one_week_ago.timestamp() * 1000)
        record = _aql_record(created_at_ms=epoch_ms)
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([record])))

        results = loader.fetch_findings_aql("access group/legal")

        assert results[0].age_days in (6, 7, 8)  # allow 1-day clock tolerance

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_none_product_or_environment_safe(self, mock_post, loader):
        """Records with null product/environment fields don't raise."""
        record = _aql_record()
        record["product"] = None
        record["environment"] = None
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([record])))

        results = loader.fetch_findings_aql("access group/legal")

        assert results[0].product == ""
        assert results[0].environment is None


class TestAgeFromEpochMs:
    def test_calculates_age_in_days(self, loader):
        """Returns correct age for a known timestamp."""
        from datetime import datetime, timedelta

        thirty_days_ago = datetime.now() - timedelta(days=30)
        epoch_ms = int(thirty_days_ago.timestamp() * 1000)
        assert loader._age_from_epoch_ms(epoch_ms) in (29, 30, 31)

    def test_zero_for_invalid_input(self, loader):
        """Returns 0 for invalid/None-like input without raising."""
        assert loader._age_from_epoch_ms(0) >= 0  # epoch 0 = 1970, very large but valid
        assert loader._age_from_epoch_ms(-1) == 0  # negative â†’ clamped to 0

    def test_future_date_returns_zero(self, loader):
        """A future timestamp returns 0, not a negative number."""
        from datetime import datetime, timedelta

        future = datetime.now() + timedelta(days=10)
        epoch_ms = int(future.timestamp() * 1000)
        assert loader._age_from_epoch_ms(epoch_ms) == 0
