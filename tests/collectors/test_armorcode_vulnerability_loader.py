"""
Tests for ArmorCode Vulnerability Detail Loader

Comprehensive test coverage for ArmorCode vulnerability loading:
- ArmorCodeVulnerabilityLoader initialization
- get_product_ids() - Product ID mapping with pagination
- load_vulnerabilities_for_products() - Full vulnerability loading pipeline
- _calculate_age_days() - Date parsing and age calculation
- group_by_product() - Vulnerability grouping
- VulnerabilityDetail dataclass properties
- Error handling (API failures, malformed data, missing config)
- Edge cases (empty results, missing fields, pagination)

Run with:
    pytest tests/collectors/test_armorcode_vulnerability_loader.py -v
"""

import json
from datetime import datetime, timedelta
from unittest.mock import Mock, patch

import pytest

from execution.collectors.armorcode_vulnerability_loader import (
    ArmorCodeVulnerabilityLoader,
    VulnerabilityDetail,
)


@pytest.fixture
def mock_config():
    """Mock ArmorCode configuration"""
    config = Mock()
    config.api_key = "test_api_key_12345"
    config.base_url = "https://api.armorcode.com"
    return config


@pytest.fixture
def mock_empty_config():
    """Mock empty ArmorCode configuration for error testing"""
    config = Mock()
    config.get_armorcode_config.side_effect = Exception("Config not available")
    return config


@pytest.fixture
def loader(mock_config):
    """Create ArmorCodeVulnerabilityLoader with mocked config"""
    with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
        mock_get_config.return_value.get_armorcode_config.return_value = mock_config
        return ArmorCodeVulnerabilityLoader()


@pytest.fixture
def loader_no_config(mock_empty_config):
    """Create loader with no config for error handling tests"""
    with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
        mock_get_config.return_value = mock_empty_config
        return ArmorCodeVulnerabilityLoader()


@pytest.fixture
def sample_products_response():
    """Sample products GraphQL response"""
    return {
        "data": {
            "products": {
                "products": [
                    {"id": "1001", "name": "API Gateway"},
                    {"id": "1002", "name": "Web App"},
                    {"id": "1003", "name": "Mobile App"},
                ],
                "pageInfo": {"hasNext": False},
            }
        }
    }


@pytest.fixture
def sample_products_response_multi_page():
    """Sample products response with multiple pages"""
    return [
        {
            "data": {
                "products": {
                    "products": [
                        {"id": "1001", "name": "Product A"},
                        {"id": "1002", "name": "Product B"},
                    ],
                    "pageInfo": {"hasNext": True},
                }
            }
        },
        {
            "data": {
                "products": {
                    "products": [
                        {"id": "1003", "name": "Product C"},
                        {"id": "1004", "name": "Product D"},
                    ],
                    "pageInfo": {"hasNext": False},
                }
            }
        },
    ]


@pytest.fixture
def sample_findings_response():
    """Sample findings GraphQL response"""
    return {
        "data": {
            "findings": {
                "findings": [
                    {
                        "id": "VULN-001",
                        "title": "SQL Injection in API",
                        "description": "SQL injection vulnerability",
                        "severity": "CRITICAL",
                        "status": "OPEN",
                        "createdAt": "Wed Dec 24 16:07:49 UTC 2025",
                    },
                    {
                        "id": "VULN-002",
                        "title": "XSS in Web Form",
                        "description": "Cross-site scripting vulnerability",
                        "severity": "HIGH",
                        "status": "CONFIRMED",
                        "createdAt": "Mon Jan 06 10:30:00 UTC 2026",
                    },
                ],
                "pageInfo": {"hasNext": False, "totalElements": 2},
            }
        }
    }


@pytest.fixture
def sample_findings_multi_page():
    """Sample findings with multiple pages"""
    return [
        {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-001",
                            "title": "Vuln 1",
                            "description": "Description 1",
                            "severity": "CRITICAL",
                            "status": "OPEN",
                            "createdAt": "Wed Dec 24 16:07:49 UTC 2025",
                        }
                    ],
                    "pageInfo": {"hasNext": True, "totalElements": 2},
                }
            }
        },
        {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-002",
                            "title": "Vuln 2",
                            "description": "Description 2",
                            "severity": "HIGH",
                            "status": "OPEN",
                            "createdAt": "Mon Jan 06 10:30:00 UTC 2026",
                        }
                    ],
                    "pageInfo": {"hasNext": False, "totalElements": 2},
                }
            }
        },
    ]


class TestVulnerabilityDetail:
    """Test VulnerabilityDetail dataclass"""

    def test_vulnerability_detail_creation(self):
        """Test creating VulnerabilityDetail instance"""
        vuln = VulnerabilityDetail(
            id="VULN-123",
            title="Test Vulnerability",
            description="Test description",
            severity="CRITICAL",
            status="OPEN",
            created_at="2026-01-01T00:00:00Z",
            product="Test Product",
            age_days=10,
        )

        assert vuln.id == "VULN-123"
        assert vuln.title == "Test Vulnerability"
        assert vuln.severity == "CRITICAL"
        assert vuln.status == "OPEN"
        assert vuln.product == "Test Product"
        assert vuln.age_days == 10

    def test_is_critical_property(self):
        """Test is_critical property"""
        critical_vuln = VulnerabilityDetail(
            id="V1",
            title="T",
            description="D",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )
        high_vuln = VulnerabilityDetail(
            id="V2", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )

        assert critical_vuln.is_critical is True
        assert high_vuln.is_critical is False

    def test_is_high_property(self):
        """Test is_high property"""
        high_vuln = VulnerabilityDetail(
            id="V1", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )
        medium_vuln = VulnerabilityDetail(
            id="V2",
            title="T",
            description="D",
            severity="MEDIUM",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert high_vuln.is_high is True
        assert medium_vuln.is_high is False

    def test_is_critical_or_high_property(self):
        """Test is_critical_or_high property"""
        critical = VulnerabilityDetail(
            id="V1",
            title="T",
            description="D",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )
        high = VulnerabilityDetail(
            id="V2", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )
        medium = VulnerabilityDetail(
            id="V3",
            title="T",
            description="D",
            severity="MEDIUM",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert critical.is_critical_or_high is True
        assert high.is_critical_or_high is True
        assert medium.is_critical_or_high is False


class TestArmorCodeVulnerabilityLoaderInit:
    """Test ArmorCodeVulnerabilityLoader initialization"""

    def test_initialization_success(self, loader, mock_config):
        """Test successful initialization with valid config"""
        assert loader.api_key == "test_api_key_12345"
        assert loader.base_url == "https://api.armorcode.com"
        assert loader.graphql_url == "https://api.armorcode.com/api/graphql"

    def test_initialization_strips_trailing_slash(self):
        """Test that trailing slash is stripped from base URL in graphql_url"""
        config = Mock()
        config.api_key = "test_key"
        config.base_url = "https://api.armorcode.com/"

        with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
            mock_get_config.return_value.get_armorcode_config.return_value = config
            loader = ArmorCodeVulnerabilityLoader()
            # base_url is stored as-is, but graphql_url strips trailing slash
            assert loader.base_url == "https://api.armorcode.com/"
            assert loader.graphql_url == "https://api.armorcode.com/api/graphql"

    def test_initialization_no_config(self, loader_no_config):
        """Test initialization when config is not available"""
        assert loader_no_config.api_key is None
        assert loader_no_config.base_url is None
        assert loader_no_config.graphql_url is None

    @patch("execution.collectors.armorcode_vulnerability_loader.print")
    def test_initialization_logs_warning_on_config_error(self, mock_print):
        """Test that config errors are logged as warnings"""
        with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
            mock_get_config.return_value.get_armorcode_config.side_effect = Exception("Config error")
            loader = ArmorCodeVulnerabilityLoader()

            assert loader.api_key is None
            mock_print.assert_called()
            call_args = str(mock_print.call_args)
            assert "[WARNING]" in call_args
            assert "ArmorCode config not available" in call_args


class TestGetProductIds:
    """Test get_product_ids() method"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_success(self, mock_post, loader, sample_products_response):
        """Test successful product ID lookup"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = sample_products_response
        mock_post.return_value = mock_response

        product_names = ["API Gateway", "Web App", "Mobile App"]
        result = loader.get_product_ids(product_names)

        assert len(result) == 3
        assert result["API Gateway"] == "1001"
        assert result["Web App"] == "1002"
        assert result["Mobile App"] == "1003"
        mock_post.assert_called_once()

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_multi_page(self, mock_post, loader, sample_products_response_multi_page):
        """Test product ID lookup with pagination"""
        mock_responses = []
        for response_data in sample_products_response_multi_page:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = response_data
            mock_responses.append(mock_response)

        mock_post.side_effect = mock_responses

        result = loader.get_product_ids(["Product A", "Product B", "Product C", "Product D"])

        assert len(result) == 4
        assert result["Product A"] == "1001"
        assert result["Product D"] == "1004"
        assert mock_post.call_count == 2

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_no_config(self, mock_post, loader_no_config):
        """Test get_product_ids without config returns empty dict"""
        result = loader_no_config.get_product_ids(["Product A"])

        assert result == {}
        mock_post.assert_not_called()

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_empty_list(self, mock_post, loader, sample_products_response):
        """Test get_product_ids with empty product list"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = sample_products_response
        mock_post.return_value = mock_response

        result = loader.get_product_ids([])

        assert len(result) == 3  # Still returns all available products

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_http_error(self, mock_post, loader):
        """Test get_product_ids handles HTTP errors"""
        mock_response = Mock()
        mock_response.status_code = 500
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_network_error(self, mock_post, loader):
        """Test get_product_ids handles network errors"""
        mock_post.side_effect = Exception("Network error")

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_malformed_response(self, mock_post, loader):
        """Test get_product_ids handles malformed response"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"invalid": "structure"}
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_empty_products_array(self, mock_post, loader):
        """Test get_product_ids with empty products array"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"data": {"products": {"products": [], "pageInfo": {"hasNext": False}}}}
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_pagination_limit(self, mock_post, loader):
        """Test get_product_ids respects max 9 pages limit (range(1,10))"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "data": {
                "products": {
                    "products": [{"id": "1", "name": "P1"}],
                    "pageInfo": {"hasNext": True},  # Always has more pages
                }
            }
        }
        mock_post.return_value = mock_response

        loader.get_product_ids(["Product A"])

        # Should only make 9 calls (range(1, 10) = pages 1-9)
        assert mock_post.call_count == 9


class TestLoadVulnerabilitiesForProducts:
    """Test load_vulnerabilities_for_products() method"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_success(self, mock_post, loader, sample_products_response, sample_findings_response):
        """Test successful vulnerability loading"""
        # Mock product ID lookup
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        # Mock findings query
        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        assert len(result) == 2
        assert result[0].id == "VULN-001"
        assert result[0].severity == "CRITICAL"
        assert result[0].product == "API Gateway"
        assert result[1].id == "VULN-002"
        assert result[1].severity == "HIGH"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_multiple_products(
        self, mock_post, loader, sample_products_response, sample_findings_response
    ):
        """Test loading vulnerabilities for multiple products"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        # One call for products, then one findings call per product
        mock_post.side_effect = [mock_product_response, mock_findings_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway", "Web App"], filter_environment=False)

        # 2 findings per product = 4 total
        assert len(result) == 4
        assert result[0].product == "API Gateway"
        assert result[2].product == "Web App"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_with_pagination(
        self, mock_post, loader, sample_products_response, sample_findings_multi_page
    ):
        """Test loading vulnerabilities with paginated results"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        # Create mock findings responses
        mock_findings_responses = []
        for findings_data in sample_findings_multi_page:
            mock_resp = Mock()
            mock_resp.status_code = 200
            mock_resp.json.return_value = findings_data
            mock_findings_responses.append(mock_resp)

        mock_post.side_effect = [mock_product_response] + mock_findings_responses

        result = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        assert len(result) == 2
        assert result[0].id == "VULN-001"
        assert result[1].id == "VULN-002"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_no_config(self, mock_post, loader_no_config):
        """Test load_vulnerabilities without config returns empty list"""
        result = loader_no_config.load_vulnerabilities_for_products(["Product A"])

        assert result == []
        mock_post.assert_not_called()

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_product_not_found(self, mock_post, loader, sample_products_response):
        """Test loading vulnerabilities for non-existent product"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response
        mock_post.return_value = mock_product_response

        result = loader.load_vulnerabilities_for_products(["Nonexistent Product"])

        # Should get product IDs but skip the missing product
        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_empty_product_ids(self, mock_post, loader):
        """Test load_vulnerabilities when no product IDs found"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = {
            "data": {"products": {"products": [], "pageInfo": {"hasNext": False}}}
        }
        mock_post.return_value = mock_product_response

        result = loader.load_vulnerabilities_for_products(["Product A"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_graphql_error(self, mock_post, loader, sample_products_response):
        """Test handling GraphQL errors in findings response"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {"errors": [{"message": "GraphQL error"}]}

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_http_error(self, mock_post, loader, sample_products_response):
        """Test handling HTTP errors during findings query"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 500

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_network_error(self, mock_post, loader, sample_products_response):
        """Test handling network errors during findings query"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_post.side_effect = [mock_product_response, Exception("Network timeout")]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_malformed_findings_response(self, mock_post, loader, sample_products_response):
        """Test handling malformed findings response structure"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {"invalid": "structure"}

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_empty_findings(self, mock_post, loader, sample_products_response):
        """Test loading when no vulnerabilities are found"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {
            "data": {"findings": {"findings": [], "pageInfo": {"hasNext": False, "totalElements": 0}}}
        }

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_missing_fields(self, mock_post, loader, sample_products_response):
        """Test handling findings with missing optional fields"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-001",
                            "severity": "CRITICAL",  # Required to pass Critical+High filter
                            # Other fields (title, description, etc.) intentionally missing
                        }
                    ],
                    "pageInfo": {"hasNext": False},
                }
            }
        }

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        assert len(result) == 1
        assert result[0].id == "VULN-001"
        assert result[0].title == ""  # Defaults to empty string
        assert result[0].description == ""
        assert result[0].severity == "CRITICAL"
        assert result[0].age_days == 0


class TestCalculateAgeDays:
    """Test _calculate_age_days() method"""

    def test_calculate_age_days_armorcode_format(self, loader):
        """Test age calculation with ArmorCode date format"""
        # Create a date 10 days ago
        past_date = datetime.now() - timedelta(days=10)
        date_str = past_date.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 10

    def test_calculate_age_days_iso_format(self, loader):
        """Test age calculation with ISO format fallback"""
        # Create a date 5 days ago
        past_date = datetime.now() - timedelta(days=5)
        date_str = past_date.strftime("%Y-%m-%dT%H:%M:%SZ")

        age = loader._calculate_age_days(date_str)

        assert age == 5

    def test_calculate_age_days_empty_string(self, loader):
        """Test age calculation with empty string"""
        age = loader._calculate_age_days("")

        assert age == 0

    def test_calculate_age_days_invalid_format(self, loader):
        """Test age calculation with invalid date format"""
        age = loader._calculate_age_days("invalid date string")

        assert age == 0

    def test_calculate_age_days_zero_days(self, loader):
        """Test age calculation for today's date"""
        today = datetime.now()
        date_str = today.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 0

    def test_calculate_age_days_recent_vulnerability(self, loader):
        """Test age calculation for recent vulnerability"""
        # 1 day ago
        yesterday = datetime.now() - timedelta(days=1)
        date_str = yesterday.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 1

    def test_calculate_age_days_old_vulnerability(self, loader):
        """Test age calculation for old vulnerability"""
        # 365 days ago
        year_ago = datetime.now() - timedelta(days=365)
        date_str = year_ago.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 365


class TestGroupByProduct:
    """Test group_by_product() method"""

    def test_group_by_product_single_product(self, loader):
        """Test grouping vulnerabilities from single product"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=2,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert len(result) == 1
        assert "Product A" in result
        assert len(result["Product A"]) == 2

    def test_group_by_product_multiple_products(self, loader):
        """Test grouping vulnerabilities from multiple products"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product B",
                age_days=2,
            ),
            VulnerabilityDetail(
                id="V3",
                title="T3",
                description="D3",
                severity="MEDIUM",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=3,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert len(result) == 2
        assert "Product A" in result
        assert "Product B" in result
        assert len(result["Product A"]) == 2
        assert len(result["Product B"]) == 1

    def test_group_by_product_empty_list(self, loader):
        """Test grouping empty vulnerability list"""
        result = loader.group_by_product([])

        assert result == {}

    def test_group_by_product_preserves_order(self, loader):
        """Test that grouping preserves vulnerability order within products"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=2,
            ),
            VulnerabilityDetail(
                id="V3",
                title="T3",
                description="D3",
                severity="MEDIUM",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=3,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert result["Product A"][0].id == "V1"
        assert result["Product A"][1].id == "V2"
        assert result["Product A"][2].id == "V3"


class TestIntegration:
    """Integration tests for full workflow"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_full_workflow_with_filtering(self, mock_post, loader, sample_products_response, sample_findings_response):
        """Test full workflow: load, filter critical/high, group by product"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        # Load vulnerabilities
        vulns = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        # Filter critical/high
        critical_high = [v for v in vulns if v.is_critical_or_high]
        assert len(critical_high) == 2

        # Group by product
        grouped = loader.group_by_product(critical_high)
        assert "API Gateway" in grouped

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_full_workflow_multiple_products(
        self, mock_post, loader, sample_products_response, sample_findings_response
    ):
        """Test full workflow with multiple products"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        mock_post.side_effect = [mock_product_response, mock_findings_response, mock_findings_response]

        # Load for multiple products
        vulns = loader.load_vulnerabilities_for_products(["API Gateway", "Web App"], filter_environment=False)

        # Should have 4 vulnerabilities total (2 per product)
        assert len(vulns) == 4

        # Group and verify
        grouped = loader.group_by_product(vulns)
        assert len(grouped) == 2
        assert all(len(v) == 2 for v in grouped.values())


class TestEdgeCases:
    """Test edge cases and unusual scenarios"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_product_with_special_characters(self, mock_post, loader):
        """Test product names with special characters"""
        special_products = {
            "data": {
                "products": {
                    "products": [
                        {"id": "1001", "name": "Product-API-v2"},
                        {"id": "1002", "name": "Product_Web.App"},
                        {"id": "1003", "name": "Product (Mobile)"},
                    ],
                    "pageInfo": {"hasNext": False},
                }
            }
        }

        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = special_products
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product-API-v2", "Product_Web.App", "Product (Mobile)"])

        assert len(result) == 3
        assert "Product-API-v2" in result
        assert "Product_Web.App" in result
        assert "Product (Mobile)" in result

    def test_vulnerability_with_long_description(self):
        """Test vulnerability with very long description"""
        long_desc = "A" * 10000

        vuln = VulnerabilityDetail(
            id="V1",
            title="Test",
            description=long_desc,
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert len(vuln.description) == 10000

    def test_vulnerability_with_unicode_characters(self):
        """Test vulnerability with unicode characters"""
        vuln = VulnerabilityDetail(
            id="V1",
            title="SQL Injection ä¸­æ–‡æµ‹è¯•",
            description="Vulnerability with Ã©mojis ðŸ”’ðŸ”“",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="Productâ„¢",
            age_days=1,
        )

        assert "ä¸­æ–‡æµ‹è¯•" in vuln.title
        assert "Ã©mojis" in vuln.description
        assert "â„¢" in vuln.product

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_zero_vulnerabilities_found(self, mock_post, loader, sample_products_response):
        """Test when products exist but have zero vulnerabilities"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {
            "data": {"findings": {"findings": [], "pageInfo": {"hasNext": False, "totalElements": 0}}}
        }

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []
        assert isinstance(result, list)
