"""
Tests for ArmorCode Vulnerability Detail Loader

Comprehensive test coverage for ArmorCode vulnerability loading:
- ArmorCodeVulnerabilityLoader initialization
- get_product_ids() - Product ID mapping with pagination
- load_vulnerabilities_for_products() - Full vulnerability loading pipeline
- _calculate_age_days() - Date parsing and age calculation
- group_by_product() - Vulnerability grouping
- VulnerabilityDetail dataclass properties
- Error handling (API failures, malformed data, missing config)
- Edge cases (empty results, missing fields, pagination)

Run with:
    pytest tests/collectors/test_armorcode_vulnerability_loader.py -v
"""

import json
from datetime import datetime, timedelta
from unittest.mock import Mock, patch

import pytest

from execution.collectors.armorcode_vulnerability_loader import (
    ArmorCodeVulnerabilityLoader,
    VulnerabilityDetail,
)


@pytest.fixture
def mock_config():
    """Mock ArmorCode configuration"""
    config = Mock()
    config.api_key = "test_api_key_12345"
    config.base_url = "https://api.armorcode.com"
    return config


@pytest.fixture
def mock_empty_config():
    """Mock empty ArmorCode configuration for error testing"""
    config = Mock()
    config.get_armorcode_config.side_effect = Exception("Config not available")
    return config


@pytest.fixture
def loader(mock_config):
    """Create ArmorCodeVulnerabilityLoader with mocked config"""
    with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
        mock_get_config.return_value.get_armorcode_config.return_value = mock_config
        return ArmorCodeVulnerabilityLoader()


@pytest.fixture
def loader_no_config(mock_empty_config):
    """Create loader with no config for error handling tests"""
    with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
        mock_get_config.return_value = mock_empty_config
        return ArmorCodeVulnerabilityLoader()


@pytest.fixture
def sample_products_response():
    """Sample products GraphQL response"""
    return {
        "data": {
            "products": {
                "products": [
                    {"id": "1001", "name": "API Gateway"},
                    {"id": "1002", "name": "Web App"},
                    {"id": "1003", "name": "Mobile App"},
                ],
                "pageInfo": {"hasNext": False},
            }
        }
    }


@pytest.fixture
def sample_products_response_multi_page():
    """Sample products response with multiple pages"""
    return [
        {
            "data": {
                "products": {
                    "products": [
                        {"id": "1001", "name": "Product A"},
                        {"id": "1002", "name": "Product B"},
                    ],
                    "pageInfo": {"hasNext": True},
                }
            }
        },
        {
            "data": {
                "products": {
                    "products": [
                        {"id": "1003", "name": "Product C"},
                        {"id": "1004", "name": "Product D"},
                    ],
                    "pageInfo": {"hasNext": False},
                }
            }
        },
    ]


@pytest.fixture
def sample_findings_response():
    """Sample findings GraphQL response"""
    return {
        "data": {
            "findings": {
                "findings": [
                    {
                        "id": "VULN-001",
                        "title": "SQL Injection in API",
                        "description": "SQL injection vulnerability",
                        "severity": "CRITICAL",
                        "status": "OPEN",
                        "createdAt": "Wed Dec 24 16:07:49 UTC 2025",
                    },
                    {
                        "id": "VULN-002",
                        "title": "XSS in Web Form",
                        "description": "Cross-site scripting vulnerability",
                        "severity": "HIGH",
                        "status": "CONFIRMED",
                        "createdAt": "Mon Jan 06 10:30:00 UTC 2026",
                    },
                ],
                "pageInfo": {"hasNext": False, "totalElements": 2},
            }
        }
    }


@pytest.fixture
def sample_findings_multi_page():
    """Sample findings with multiple pages"""
    return [
        {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-001",
                            "title": "Vuln 1",
                            "description": "Description 1",
                            "severity": "CRITICAL",
                            "status": "OPEN",
                            "createdAt": "Wed Dec 24 16:07:49 UTC 2025",
                        }
                    ],
                    "pageInfo": {"hasNext": True, "totalElements": 2},
                }
            }
        },
        {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-002",
                            "title": "Vuln 2",
                            "description": "Description 2",
                            "severity": "HIGH",
                            "status": "OPEN",
                            "createdAt": "Mon Jan 06 10:30:00 UTC 2026",
                        }
                    ],
                    "pageInfo": {"hasNext": False, "totalElements": 2},
                }
            }
        },
    ]


class TestVulnerabilityDetail:
    """Test VulnerabilityDetail dataclass"""

    def test_vulnerability_detail_creation(self):
        """Test creating VulnerabilityDetail instance"""
        vuln = VulnerabilityDetail(
            id="VULN-123",
            title="Test Vulnerability",
            description="Test description",
            severity="CRITICAL",
            status="OPEN",
            created_at="2026-01-01T00:00:00Z",
            product="Test Product",
            age_days=10,
        )

        assert vuln.id == "VULN-123"
        assert vuln.title == "Test Vulnerability"
        assert vuln.severity == "CRITICAL"
        assert vuln.status == "OPEN"
        assert vuln.product == "Test Product"
        assert vuln.age_days == 10

    def test_is_critical_property(self):
        """Test is_critical property"""
        critical_vuln = VulnerabilityDetail(
            id="V1",
            title="T",
            description="D",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )
        high_vuln = VulnerabilityDetail(
            id="V2", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )

        assert critical_vuln.is_critical is True
        assert high_vuln.is_critical is False

    def test_is_high_property(self):
        """Test is_high property"""
        high_vuln = VulnerabilityDetail(
            id="V1", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )
        medium_vuln = VulnerabilityDetail(
            id="V2",
            title="T",
            description="D",
            severity="MEDIUM",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert high_vuln.is_high is True
        assert medium_vuln.is_high is False

    def test_is_critical_or_high_property(self):
        """Test is_critical_or_high property"""
        critical = VulnerabilityDetail(
            id="V1",
            title="T",
            description="D",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )
        high = VulnerabilityDetail(
            id="V2", title="T", description="D", severity="HIGH", status="OPEN", created_at="", product="P", age_days=1
        )
        medium = VulnerabilityDetail(
            id="V3",
            title="T",
            description="D",
            severity="MEDIUM",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert critical.is_critical_or_high is True
        assert high.is_critical_or_high is True
        assert medium.is_critical_or_high is False


class TestArmorCodeVulnerabilityLoaderInit:
    """Test ArmorCodeVulnerabilityLoader initialization"""

    def test_initialization_success(self, loader, mock_config):
        """Test successful initialization with valid config"""
        assert loader.api_key == "test_api_key_12345"
        assert loader.base_url == "https://api.armorcode.com"
        assert loader.graphql_url == "https://api.armorcode.com/api/graphql"

    def test_initialization_strips_trailing_slash(self):
        """Test that trailing slash is stripped from base URL in graphql_url"""
        config = Mock()
        config.api_key = "test_key"
        config.base_url = "https://api.armorcode.com/"

        with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
            mock_get_config.return_value.get_armorcode_config.return_value = config
            loader = ArmorCodeVulnerabilityLoader()
            # base_url is stored as-is, but graphql_url strips trailing slash
            assert loader.base_url == "https://api.armorcode.com/"
            assert loader.graphql_url == "https://api.armorcode.com/api/graphql"

    def test_initialization_no_config(self, loader_no_config):
        """Test initialization when config is not available"""
        assert loader_no_config.api_key is None
        assert loader_no_config.base_url is None
        assert loader_no_config.graphql_url is None

    @patch("execution.collectors.armorcode_vulnerability_loader.print")
    def test_initialization_logs_warning_on_config_error(self, mock_print):
        """Test that config errors are logged as warnings"""
        with patch("execution.collectors.armorcode_vulnerability_loader.get_config") as mock_get_config:
            mock_get_config.return_value.get_armorcode_config.side_effect = Exception("Config error")
            loader = ArmorCodeVulnerabilityLoader()

            assert loader.api_key is None
            mock_print.assert_called()
            call_args = str(mock_print.call_args)
            assert "[WARNING]" in call_args
            assert "ArmorCode config not available" in call_args


class TestGetProductIds:
    """Test get_product_ids() method"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_success(self, mock_post, loader, sample_products_response):
        """Test successful product ID lookup"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = sample_products_response
        mock_post.return_value = mock_response

        product_names = ["API Gateway", "Web App", "Mobile App"]
        result = loader.get_product_ids(product_names)

        assert len(result) == 3
        assert result["API Gateway"] == "1001"
        assert result["Web App"] == "1002"
        assert result["Mobile App"] == "1003"
        mock_post.assert_called_once()

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_multi_page(self, mock_post, loader, sample_products_response_multi_page):
        """Test product ID lookup with pagination"""
        mock_responses = []
        for response_data in sample_products_response_multi_page:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = response_data
            mock_responses.append(mock_response)

        mock_post.side_effect = mock_responses

        result = loader.get_product_ids(["Product A", "Product B", "Product C", "Product D"])

        assert len(result) == 4
        assert result["Product A"] == "1001"
        assert result["Product D"] == "1004"
        assert mock_post.call_count == 2

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_no_config(self, mock_post, loader_no_config):
        """Test get_product_ids without config returns empty dict"""
        result = loader_no_config.get_product_ids(["Product A"])

        assert result == {}
        mock_post.assert_not_called()

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_empty_list(self, mock_post, loader, sample_products_response):
        """Test get_product_ids with empty product list"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = sample_products_response
        mock_post.return_value = mock_response

        result = loader.get_product_ids([])

        assert len(result) == 3  # Still returns all available products

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_http_error(self, mock_post, loader):
        """Test get_product_ids handles HTTP errors"""
        mock_response = Mock()
        mock_response.status_code = 500
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_network_error(self, mock_post, loader):
        """Test get_product_ids handles network errors"""
        mock_post.side_effect = Exception("Network error")

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_malformed_response(self, mock_post, loader):
        """Test get_product_ids handles malformed response"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"invalid": "structure"}
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_empty_products_array(self, mock_post, loader):
        """Test get_product_ids with empty products array"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"data": {"products": {"products": [], "pageInfo": {"hasNext": False}}}}
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product A"])

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_get_product_ids_pagination_limit(self, mock_post, loader):
        """Test get_product_ids respects max 9 pages limit (range(1,10))"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "data": {
                "products": {
                    "products": [{"id": "1", "name": "P1"}],
                    "pageInfo": {"hasNext": True},  # Always has more pages
                }
            }
        }
        mock_post.return_value = mock_response

        loader.get_product_ids(["Product A"])

        # Should only make 9 calls (range(1, 10) = pages 1-9)
        assert mock_post.call_count == 9


class TestLoadVulnerabilitiesForProducts:
    """Test load_vulnerabilities_for_products() method"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_success(self, mock_post, loader, sample_products_response, sample_findings_response):
        """Test successful vulnerability loading"""
        # Mock product ID lookup
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        # Mock findings query
        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        assert len(result) == 2
        assert result[0].id == "VULN-001"
        assert result[0].severity == "CRITICAL"
        assert result[0].product == "API Gateway"
        assert result[1].id == "VULN-002"
        assert result[1].severity == "HIGH"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_multiple_products(
        self, mock_post, loader, sample_products_response, sample_findings_response
    ):
        """Test loading vulnerabilities for multiple products"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        # One call for products, then one findings call per product
        mock_post.side_effect = [mock_product_response, mock_findings_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway", "Web App"], filter_environment=False)

        # 2 findings per product = 4 total
        assert len(result) == 4
        assert result[0].product == "API Gateway"
        assert result[2].product == "Web App"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_with_pagination(
        self, mock_post, loader, sample_products_response, sample_findings_multi_page
    ):
        """Test loading vulnerabilities with paginated results"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        # Create mock findings responses
        mock_findings_responses = []
        for findings_data in sample_findings_multi_page:
            mock_resp = Mock()
            mock_resp.status_code = 200
            mock_resp.json.return_value = findings_data
            mock_findings_responses.append(mock_resp)

        mock_post.side_effect = [mock_product_response] + mock_findings_responses

        result = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        assert len(result) == 2
        assert result[0].id == "VULN-001"
        assert result[1].id == "VULN-002"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_no_config(self, mock_post, loader_no_config):
        """Test load_vulnerabilities without config returns empty list"""
        result = loader_no_config.load_vulnerabilities_for_products(["Product A"])

        assert result == []
        mock_post.assert_not_called()

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_product_not_found(self, mock_post, loader, sample_products_response):
        """Test loading vulnerabilities for non-existent product"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response
        mock_post.return_value = mock_product_response

        result = loader.load_vulnerabilities_for_products(["Nonexistent Product"])

        # Should get product IDs but skip the missing product
        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_empty_product_ids(self, mock_post, loader):
        """Test load_vulnerabilities when no product IDs found"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = {
            "data": {"products": {"products": [], "pageInfo": {"hasNext": False}}}
        }
        mock_post.return_value = mock_product_response

        result = loader.load_vulnerabilities_for_products(["Product A"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_graphql_error(self, mock_post, loader, sample_products_response):
        """Test handling GraphQL errors in findings response"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {"errors": [{"message": "GraphQL error"}]}

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_http_error(self, mock_post, loader, sample_products_response):
        """Test handling HTTP errors during findings query"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 500

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_network_error(self, mock_post, loader, sample_products_response):
        """Test handling network errors during findings query"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_post.side_effect = [mock_product_response, Exception("Network timeout")]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_malformed_findings_response(self, mock_post, loader, sample_products_response):
        """Test handling malformed findings response structure"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {"invalid": "structure"}

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_empty_findings(self, mock_post, loader, sample_products_response):
        """Test loading when no vulnerabilities are found"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {
            "data": {"findings": {"findings": [], "pageInfo": {"hasNext": False, "totalElements": 0}}}
        }

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_load_vulnerabilities_missing_fields(self, mock_post, loader, sample_products_response):
        """Test handling findings with missing optional fields"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {
            "data": {
                "findings": {
                    "findings": [
                        {
                            "id": "VULN-001",
                            "severity": "CRITICAL",  # Required to pass Critical+High filter
                            # Other fields (title, description, etc.) intentionally missing
                        }
                    ],
                    "pageInfo": {"hasNext": False},
                }
            }
        }

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        assert len(result) == 1
        assert result[0].id == "VULN-001"
        assert result[0].title == ""  # Defaults to empty string
        assert result[0].description == ""
        assert result[0].severity == "CRITICAL"
        assert result[0].age_days == 0


class TestCalculateAgeDays:
    """Test _calculate_age_days() method"""

    def test_calculate_age_days_armorcode_format(self, loader):
        """Test age calculation with ArmorCode date format"""
        # Create a date 10 days ago
        past_date = datetime.now() - timedelta(days=10)
        date_str = past_date.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 10

    def test_calculate_age_days_iso_format(self, loader):
        """Test age calculation with ISO format fallback"""
        # Create a date 5 days ago
        past_date = datetime.now() - timedelta(days=5)
        date_str = past_date.strftime("%Y-%m-%dT%H:%M:%SZ")

        age = loader._calculate_age_days(date_str)

        assert age == 5

    def test_calculate_age_days_empty_string(self, loader):
        """Test age calculation with empty string"""
        age = loader._calculate_age_days("")

        assert age == 0

    def test_calculate_age_days_invalid_format(self, loader):
        """Test age calculation with invalid date format"""
        age = loader._calculate_age_days("invalid date string")

        assert age == 0

    def test_calculate_age_days_zero_days(self, loader):
        """Test age calculation for today's date"""
        today = datetime.now()
        date_str = today.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 0

    def test_calculate_age_days_recent_vulnerability(self, loader):
        """Test age calculation for recent vulnerability"""
        # 1 day ago
        yesterday = datetime.now() - timedelta(days=1)
        date_str = yesterday.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 1

    def test_calculate_age_days_old_vulnerability(self, loader):
        """Test age calculation for old vulnerability"""
        # 365 days ago
        year_ago = datetime.now() - timedelta(days=365)
        date_str = year_ago.strftime("%a %b %d %H:%M:%S UTC %Y")

        age = loader._calculate_age_days(date_str)

        assert age == 365


class TestGroupByProduct:
    """Test group_by_product() method"""

    def test_group_by_product_single_product(self, loader):
        """Test grouping vulnerabilities from single product"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=2,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert len(result) == 1
        assert "Product A" in result
        assert len(result["Product A"]) == 2

    def test_group_by_product_multiple_products(self, loader):
        """Test grouping vulnerabilities from multiple products"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product B",
                age_days=2,
            ),
            VulnerabilityDetail(
                id="V3",
                title="T3",
                description="D3",
                severity="MEDIUM",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=3,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert len(result) == 2
        assert "Product A" in result
        assert "Product B" in result
        assert len(result["Product A"]) == 2
        assert len(result["Product B"]) == 1

    def test_group_by_product_empty_list(self, loader):
        """Test grouping empty vulnerability list"""
        result = loader.group_by_product([])

        assert result == {}

    def test_group_by_product_preserves_order(self, loader):
        """Test that grouping preserves vulnerability order within products"""
        vulns = [
            VulnerabilityDetail(
                id="V1",
                title="T1",
                description="D1",
                severity="CRITICAL",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=1,
            ),
            VulnerabilityDetail(
                id="V2",
                title="T2",
                description="D2",
                severity="HIGH",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=2,
            ),
            VulnerabilityDetail(
                id="V3",
                title="T3",
                description="D3",
                severity="MEDIUM",
                status="OPEN",
                created_at="",
                product="Product A",
                age_days=3,
            ),
        ]

        result = loader.group_by_product(vulns)

        assert result["Product A"][0].id == "V1"
        assert result["Product A"][1].id == "V2"
        assert result["Product A"][2].id == "V3"


class TestIntegration:
    """Integration tests for full workflow"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_full_workflow_with_filtering(self, mock_post, loader, sample_products_response, sample_findings_response):
        """Test full workflow: load, filter critical/high, group by product"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        # Load vulnerabilities
        vulns = loader.load_vulnerabilities_for_products(["API Gateway"], filter_environment=False)

        # Filter critical/high
        critical_high = [v for v in vulns if v.is_critical_or_high]
        assert len(critical_high) == 2

        # Group by product
        grouped = loader.group_by_product(critical_high)
        assert "API Gateway" in grouped

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_full_workflow_multiple_products(
        self, mock_post, loader, sample_products_response, sample_findings_response
    ):
        """Test full workflow with multiple products"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = sample_findings_response

        mock_post.side_effect = [mock_product_response, mock_findings_response, mock_findings_response]

        # Load for multiple products
        vulns = loader.load_vulnerabilities_for_products(["API Gateway", "Web App"], filter_environment=False)

        # Should have 4 vulnerabilities total (2 per product)
        assert len(vulns) == 4

        # Group and verify
        grouped = loader.group_by_product(vulns)
        assert len(grouped) == 2
        assert all(len(v) == 2 for v in grouped.values())


class TestEdgeCases:
    """Test edge cases and unusual scenarios"""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_product_with_special_characters(self, mock_post, loader):
        """Test product names with special characters"""
        special_products = {
            "data": {
                "products": {
                    "products": [
                        {"id": "1001", "name": "Product-API-v2"},
                        {"id": "1002", "name": "Product_Web.App"},
                        {"id": "1003", "name": "Product (Mobile)"},
                    ],
                    "pageInfo": {"hasNext": False},
                }
            }
        }

        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = special_products
        mock_post.return_value = mock_response

        result = loader.get_product_ids(["Product-API-v2", "Product_Web.App", "Product (Mobile)"])

        assert len(result) == 3
        assert "Product-API-v2" in result
        assert "Product_Web.App" in result
        assert "Product (Mobile)" in result

    def test_vulnerability_with_long_description(self):
        """Test vulnerability with very long description"""
        long_desc = "A" * 10000

        vuln = VulnerabilityDetail(
            id="V1",
            title="Test",
            description=long_desc,
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="P",
            age_days=1,
        )

        assert len(vuln.description) == 10000

    def test_vulnerability_with_unicode_characters(self):
        """Test vulnerability with unicode characters"""
        vuln = VulnerabilityDetail(
            id="V1",
            title="SQL Injection ä¸­æ–‡æµ‹è¯•",
            description="Vulnerability with Ã©mojis ðŸ”’ðŸ”“",
            severity="CRITICAL",
            status="OPEN",
            created_at="",
            product="Productâ„¢",
            age_days=1,
        )

        assert "ä¸­æ–‡æµ‹è¯•" in vuln.title
        assert "Ã©mojis" in vuln.description
        assert "â„¢" in vuln.product

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_zero_vulnerabilities_found(self, mock_post, loader, sample_products_response):
        """Test when products exist but have zero vulnerabilities"""
        mock_product_response = Mock()
        mock_product_response.status_code = 200
        mock_product_response.json.return_value = sample_products_response

        mock_findings_response = Mock()
        mock_findings_response.status_code = 200
        mock_findings_response.json.return_value = {
            "data": {"findings": {"findings": [], "pageInfo": {"hasNext": False, "totalElements": 0}}}
        }

        mock_post.side_effect = [mock_product_response, mock_findings_response]

        result = loader.load_vulnerabilities_for_products(["API Gateway"])

        assert result == []
        assert isinstance(result, list)


class TestLoadVulnerabilitiesHybrid:
    """Tests for load_vulnerabilities_hybrid() per-bucket fetch logic."""

    def test_fetches_all_sources_per_product(self, loader):
        """
        All 11 sources in SOURCE_BUCKET_MAP get a separate _fetch_product_pages call.
        Detail records are capped at max_per_bucket per source.
        Bucket counts are returned as None â€” computed by the caller via AQL.

        Scenario: product has Prisma Cloud Redlock (CLOUD) and Cortex XDR (INFRA) findings.
        All 11 sources are tried; empty results for sources with no findings are harmless.
        """
        from unittest.mock import patch

        from execution.collectors.armorcode_vulnerability_loader import VulnerabilityDetail

        def make_vuln(source: str, severity: str = "HIGH") -> VulnerabilityDetail:
            return VulnerabilityDetail(
                id=f"id-{source[:3]}",
                title="t",
                description="",
                severity=severity,
                status="OPEN",
                created_at="",
                product="Access Legal",
                age_days=5,
                source=source,
                environment="Production",
            )

        cloud_redlock_vulns = [make_vuln("Prisma Cloud Redlock")] * 29
        infra_cortex_vulns = [make_vuln("Cortex XDR")] * 40
        empty: list = []

        # Side effects for all 11 sources in SOURCE_BUCKET_MAP order:
        # CODE: Mend, SonarQube, Custom-Pentest
        # CLOUD: Prisma Cloud Twistlock, Prisma Cloud Redlock, Prisma Cloud Compute
        # INFRA: Cortex XDR, Tenable Infrastructure, Tenable Vulnerability Management, AppCheck, BitSight
        page_side_effects = [
            (empty, 0),  # Mend (CODE)
            (empty, 0),  # SonarQube (CODE)
            (empty, 0),  # Custom-Pentest (CODE)
            (empty, 0),  # Prisma Cloud Twistlock (CLOUD)
            (cloud_redlock_vulns, 29),  # Prisma Cloud Redlock (CLOUD)
            (empty, 0),  # Prisma Cloud Compute (CLOUD)
            (infra_cortex_vulns, 40),  # Cortex XDR (INFRA)
            (empty, 0),  # Tenable Infrastructure (INFRA)
            (empty, 0),  # Tenable Vulnerability Management (INFRA)
            (empty, 0),  # AppCheck (INFRA)
            (empty, 0),  # BitSight (INFRA)
        ]

        with (
            patch.object(loader, "get_product_ids", return_value={"Access Legal": "pid-42"}),
            patch.object(loader, "_fetch_product_pages", side_effect=page_side_effects) as mock_pages,
            patch.object(loader, "_count_product_severity", return_value=0),
            patch.object(loader, "filter_by_environment", side_effect=lambda v: v),
        ):
            vulns, bucket_counts, _, _ = loader.load_vulnerabilities_hybrid(
                ["Access Legal"], filter_environment=True, max_per_bucket=50
            )

        # All 11 sources are tried (no pre-filtering by bucket)
        assert mock_pages.call_count == 11
        fetched_sources = [c.kwargs.get("source") or c.args[3] for c in mock_pages.call_args_list]
        assert "Prisma Cloud Redlock" in fetched_sources
        assert "Cortex XDR" in fetched_sources
        assert "Mend" in fetched_sources  # CODE sources now attempted too
        assert "SonarQube" in fetched_sources  # CODE sources now attempted too

        # All 29 CLOUD records are included (â‰¤ 50 cap)
        cloud_result = [v for v in vulns if v.source == "Prisma Cloud Redlock"]
        assert len(cloud_result) == 29

        # Bucket counts are None â€” AQL counts are computed by the caller (security_enhanced.py)
        assert bucket_counts["Access Legal"] is None


class TestCountByBucketAql:
    """Tests for count_by_bucket_aql() method."""

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_per_product_counts_for_code_bucket(self, mock_post, loader):
        """CODE bucket AQL returns per-product counts filtered to CODE sources."""
        mock_resp = Mock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "pid-1": {"count": 10},
            "pid-2": {"count": 5},
        }
        mock_post.return_value = mock_resp

        result = loader.count_by_bucket_aql("CODE", "Critical", "access group/legal")

        assert result == {"pid-1": 10, "pid-2": 5}
        # Verify AQL payload includes source filter for CODE sources
        call_kwargs = mock_post.call_args[1]
        payload = call_kwargs["json"]
        aql = payload["filters"]["aqlQuery"][0]
        assert "source IN" in aql
        assert "Mend" in aql
        assert "SonarQube" in aql
        assert "Custom-Pentest" in aql
        assert "environment = Production" in aql
        assert "severity = Critical" in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_per_product_counts_for_cloud_bucket(self, mock_post, loader):
        """CLOUD bucket AQL uses Prisma Cloud sources."""
        mock_resp = Mock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {"pid-3": {"count": 29}}
        mock_post.return_value = mock_resp

        result = loader.count_by_bucket_aql("CLOUD", "High", "access group/legal")

        assert result == {"pid-3": 29}
        call_kwargs = mock_post.call_args[1]
        aql = call_kwargs["json"]["filters"]["aqlQuery"][0]
        assert "Prisma Cloud" in aql
        assert "severity = High" in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_empty_on_http_error(self, mock_post, loader):
        """Returns empty dict on HTTP error."""
        mock_resp = Mock()
        mock_resp.status_code = 500
        mock_resp.text = "Internal Server Error"
        mock_post.return_value = mock_resp

        result = loader.count_by_bucket_aql("CODE", "Critical", "access group/legal")

        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_empty_on_network_error(self, mock_post, loader):
        """Returns empty dict on network failure."""
        mock_post.side_effect = Exception("Connection refused")

        result = loader.count_by_bucket_aql("CODE", "Critical", "access group/legal")

        assert result == {}

    def test_returns_empty_when_no_config(self, loader_no_config):
        """Returns empty dict when ArmorCode is not configured."""
        result = loader_no_config.count_by_bucket_aql("CODE", "Critical", "access group/legal")
        assert result == {}

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_quotes_sources_with_spaces_and_hyphens(self, mock_post, loader):
        """Source names with spaces or hyphens are quoted in AQL."""
        mock_resp = Mock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {}
        mock_post.return_value = mock_resp

        loader.count_by_bucket_aql("INFRASTRUCTURE", "High", "access group/legal")

        call_kwargs = mock_post.call_args[1]
        aql = call_kwargs["json"]["filters"]["aqlQuery"][0]
        # Cortex XDR has a space â†’ must be quoted
        assert "'Cortex XDR'" in aql
        # AppCheck has no space/hyphen â†’ unquoted
        assert "AppCheck" in aql


# ---------------------------------------------------------------------------
# fetch_findings_aql + _age_from_epoch_ms
# ---------------------------------------------------------------------------


def _aql_record(
    id: str = "7939440927",
    title: str = "CVE-2026-26996 | minimatch",
    severity: str = "HIGH",
    status: str = "CONFIRMED",
    source: str = "Mend",
    product_name: str = "inCase",
    environment_name: str = "Production",
    created_at_ms: int = 1771478352000,
    description: str = "A vulnerability description",
) -> dict:
    """Minimal AQL /user/findings/ record matching the real API shape."""
    return {
        "id": int(id),
        "title": title,
        "severity": severity,
        "status": status,
        "source": source,
        "createdAt": created_at_ms,
        "description": description,
        "product": {"id": 227595, "name": product_name},
        "environment": {"id": 1337433, "name": environment_name},
        "subProduct": {"id": 677117, "name": f"{product_name}-client"},
    }


def _page_response(content: list, last: bool = True, total: int | None = None) -> dict:
    """Minimal Spring Page<T> wrapper."""
    return {
        "content": content,
        "last": last,
        "totalElements": total if total is not None else len(content),
        "pageable": {"pageNumber": 0, "pageSize": len(content)},
    }


class TestFetchFindingsAql:
    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_vulnerability_details(self, mock_post, loader):
        """Maps AQL record fields to VulnerabilityDetail correctly."""
        record = _aql_record(id="123", title="Test vuln", severity="CRITICAL", source="SonarQube")
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([record])))

        results = loader.fetch_findings_aql("access group/legal")

        assert len(results) == 1
        vuln = results[0]
        assert vuln.id == "123"
        assert vuln.title == "Test vuln"
        assert vuln.severity == "CRITICAL"
        assert vuln.source == "SonarQube"
        assert vuln.product == "inCase"
        assert vuln.environment == "Production"

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_paginates_until_last(self, mock_post, loader):
        """Fetches multiple pages and stops when last=True."""
        page1 = _page_response([_aql_record(id="1")], last=False, total=2)
        page2 = _page_response([_aql_record(id="2")], last=True, total=2)
        mock_post.return_value = Mock(status_code=200, json=Mock(side_effect=[page1, page2]))

        # page_size=1 so len(content)==page_size â€” only last=True triggers the stop
        results = loader.fetch_findings_aql("access group/legal", page_size=1)

        assert len(results) == 2
        assert mock_post.call_count == 2

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_uses_size_1000_by_default(self, mock_post, loader):
        """Default page_size is 1000."""
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([])))

        loader.fetch_findings_aql("access group/legal")

        payload = mock_post.call_args[1]["json"]
        assert payload["size"] == 1000

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_aql_contains_hierarchy_and_environment(self, mock_post, loader):
        """AQL string contains hierarchy filter and environment filter."""
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([])))

        loader.fetch_findings_aql("access group/legal", environment="Production")

        payload = mock_post.call_args[1]["json"]
        aql = payload["filters"]["aqlQuery"][0]
        assert "armorcode.group:access group/legal" in aql
        assert "environment = Production" in aql
        assert "severity IN (High,Critical)" in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_no_environment_filter_when_none(self, mock_post, loader):
        """Passing environment=None omits the environment clause."""
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([])))

        loader.fetch_findings_aql("access group/legal", environment=None)

        aql = mock_post.call_args[1]["json"]["filters"]["aqlQuery"][0]
        assert "environment" not in aql

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_returns_empty_on_http_error(self, mock_post, loader):
        """Returns empty list when API returns non-200."""
        mock_post.return_value = Mock(status_code=429, text="Too Many Requests")

        results = loader.fetch_findings_aql("access group/legal")

        assert results == []

    def test_returns_empty_when_not_configured(self, loader_no_config):
        """Returns empty list when API key is not configured."""
        results = loader_no_config.fetch_findings_aql("access group/legal")
        assert results == []

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_age_calculated_from_epoch_ms(self, mock_post, loader):
        """age_days is derived from epoch millisecond createdAt."""
        from datetime import datetime, timedelta

        one_week_ago = datetime.now() - timedelta(days=7)
        epoch_ms = int(one_week_ago.timestamp() * 1000)
        record = _aql_record(created_at_ms=epoch_ms)
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([record])))

        results = loader.fetch_findings_aql("access group/legal")

        assert results[0].age_days in (6, 7, 8)  # allow 1-day clock tolerance

    @patch("execution.collectors.armorcode_vulnerability_loader.post")
    def test_none_product_or_environment_safe(self, mock_post, loader):
        """Records with null product/environment fields don't raise."""
        record = _aql_record()
        record["product"] = None
        record["environment"] = None
        mock_post.return_value = Mock(status_code=200, json=Mock(return_value=_page_response([record])))

        results = loader.fetch_findings_aql("access group/legal")

        assert results[0].product == ""
        assert results[0].environment is None


class TestAgeFromEpochMs:
    def test_calculates_age_in_days(self, loader):
        """Returns correct age for a known timestamp."""
        from datetime import datetime, timedelta

        thirty_days_ago = datetime.now() - timedelta(days=30)
        epoch_ms = int(thirty_days_ago.timestamp() * 1000)
        assert loader._age_from_epoch_ms(epoch_ms) in (29, 30, 31)

    def test_zero_for_invalid_input(self, loader):
        """Returns 0 for invalid/None-like input without raising."""
        assert loader._age_from_epoch_ms(0) >= 0  # epoch 0 = 1970, very large but valid
        assert loader._age_from_epoch_ms(-1) == 0  # negative â†’ clamped to 0

    def test_future_date_returns_zero(self, loader):
        """A future timestamp returns 0, not a negative number."""
        from datetime import datetime, timedelta

        future = datetime.now() + timedelta(days=10)
        epoch_ms = int(future.timestamp() * 1000)
        assert loader._age_from_epoch_ms(epoch_ms) == 0
