"""
Tests for ArmorCode Exploitable Collector — _save_to_history deduplication.

Tests cover:
- New entry is appended when history is empty
- New entry is appended when no entry exists for the same week_date
- Existing entry for the same week_date is replaced (not duplicated)
- Multiple different week_dates are preserved
- Replacing preserves order of other weeks
"""

import json
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from execution.collectors.armorcode_exploitable_collector import _save_to_history

# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


def _make_week(week_date: str, total: int, products: dict | None = None) -> dict:
    """Helper to build a minimal week_data dict."""
    return {
        "week_date": week_date,
        "week_number": 8,
        "metrics": {
            "current_total": total,
            "severity_breakdown": {"critical": 0, "high": total, "medium": 0, "total": total},
            "product_breakdown": products or {"Eclipse": {"critical": 0, "high": total, "medium": 0, "total": total}},
            "collected_at": f"{week_date}T10:00:00",
        },
    }


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------


class TestSaveToHistory:
    """Test _save_to_history() deduplication logic."""

    def test_creates_new_file_when_not_exists(self, tmp_path):
        history_path = tmp_path / "exploitable_history.json"
        week_data = _make_week("2026-02-20", 100)

        with patch("execution.collectors.armorcode_exploitable_collector.HISTORY_PATH", history_path):
            _save_to_history(week_data)

        assert history_path.exists()
        saved = json.loads(history_path.read_text())
        assert len(saved["weeks"]) == 1
        assert saved["weeks"][0]["week_date"] == "2026-02-20"

    def test_appends_when_different_week_date(self, tmp_path):
        history_path = tmp_path / "exploitable_history.json"
        existing = {"weeks": [_make_week("2026-02-13", 50)]}
        history_path.write_text(json.dumps(existing))

        new_entry = _make_week("2026-02-20", 100)

        with patch("execution.collectors.armorcode_exploitable_collector.HISTORY_PATH", history_path):
            _save_to_history(new_entry)

        saved = json.loads(history_path.read_text())
        assert len(saved["weeks"]) == 2
        dates = [w["week_date"] for w in saved["weeks"]]
        assert "2026-02-13" in dates
        assert "2026-02-20" in dates

    def test_replaces_existing_entry_for_same_week_date(self, tmp_path):
        """Re-running the collector on the same day must replace, not duplicate."""
        history_path = tmp_path / "exploitable_history.json"
        old_entry = _make_week(
            "2026-02-20", 50, products={"Eclipse": {"critical": 0, "high": 50, "medium": 0, "total": 50}}
        )
        existing = {"weeks": [old_entry]}
        history_path.write_text(json.dumps(existing))

        new_entry = _make_week(
            "2026-02-20",
            674,
            products={
                "Eclipse": {"critical": 9, "high": 529, "medium": 115, "total": 653},
                "Law Fusion": {"critical": 0, "high": 0, "medium": 1, "total": 1},
            },
        )

        with patch("execution.collectors.armorcode_exploitable_collector.HISTORY_PATH", history_path):
            _save_to_history(new_entry)

        saved = json.loads(history_path.read_text())
        # Must have exactly one entry for 2026-02-20 — not two
        assert len(saved["weeks"]) == 1
        assert saved["weeks"][0]["metrics"]["current_total"] == 674
        assert "Law Fusion" in saved["weeks"][0]["metrics"]["product_breakdown"]

    def test_does_not_duplicate_on_second_run(self, tmp_path):
        """Running collector twice on same day must not create two entries."""
        history_path = tmp_path / "exploitable_history.json"
        first = _make_week("2026-02-20", 100)
        existing = {"weeks": [first]}
        history_path.write_text(json.dumps(existing))

        second = _make_week("2026-02-20", 200)

        with patch("execution.collectors.armorcode_exploitable_collector.HISTORY_PATH", history_path):
            _save_to_history(second)

        saved = json.loads(history_path.read_text())
        week_20_entries = [w for w in saved["weeks"] if w["week_date"] == "2026-02-20"]
        assert len(week_20_entries) == 1

    def test_preserves_other_weeks_when_replacing(self, tmp_path):
        """Replacing today's entry must not affect previous weeks."""
        history_path = tmp_path / "exploitable_history.json"
        existing = {
            "weeks": [
                _make_week("2026-02-06", 30),
                _make_week("2026-02-13", 40),
                _make_week("2026-02-20", 50),
            ]
        }
        history_path.write_text(json.dumps(existing))

        new_entry = _make_week("2026-02-20", 99)

        with patch("execution.collectors.armorcode_exploitable_collector.HISTORY_PATH", history_path):
            _save_to_history(new_entry)

        saved = json.loads(history_path.read_text())
        assert len(saved["weeks"]) == 3
        totals_by_date = {w["week_date"]: w["metrics"]["current_total"] for w in saved["weeks"]}
        assert totals_by_date["2026-02-06"] == 30
        assert totals_by_date["2026-02-13"] == 40
        assert totals_by_date["2026-02-20"] == 99

    def test_appends_to_empty_weeks_list(self, tmp_path):
        history_path = tmp_path / "exploitable_history.json"
        history_path.write_text(json.dumps({"weeks": []}))

        week_data = _make_week("2026-02-20", 10)

        with patch("execution.collectors.armorcode_exploitable_collector.HISTORY_PATH", history_path):
            _save_to_history(week_data)

        saved = json.loads(history_path.read_text())
        assert len(saved["weeks"]) == 1

    def test_saved_json_is_valid(self, tmp_path):
        history_path = tmp_path / "exploitable_history.json"
        week_data = _make_week("2026-02-20", 42)

        with patch("execution.collectors.armorcode_exploitable_collector.HISTORY_PATH", history_path):
            _save_to_history(week_data)

        content = history_path.read_text()
        parsed = json.loads(content)
        assert "weeks" in parsed


class TestCollectExploitableMetrics:
    """Test collect_exploitable_metrics() includes zero-count products."""

    def test_zero_count_products_included_in_breakdown(self):
        """All hierarchy products appear in product_breakdown, even those with zero findings."""
        from execution.collectors.armorcode_exploitable_collector import collect_exploitable_metrics

        name_to_id = {"Eclipse": "1", "CleanProduct": "2", "AnotherProduct": "3"}
        # Only Eclipse has findings; the others return 0 from the count endpoint
        critical_counts = {"1": 5}
        high_counts = {"1": 10}
        medium_counts: dict[str, int] = {}

        with (
            patch(
                "execution.collectors.armorcode_exploitable_collector._get_products_by_hierarchy",
                return_value=name_to_id,
            ),
            patch(
                "execution.collectors.armorcode_exploitable_collector._count_by_severity",
                side_effect=[critical_counts, high_counts, medium_counts],
            ),
            patch("execution.collectors.armorcode_exploitable_collector.get_config") as mock_cfg,
        ):
            mock_cfg.return_value.get_optional_env.return_value = "test-hierarchy"
            result = collect_exploitable_metrics()

        breakdown = result["metrics"]["product_breakdown"]
        assert "Eclipse" in breakdown
        assert "CleanProduct" in breakdown
        assert "AnotherProduct" in breakdown

    def test_zero_count_product_has_correct_structure(self):
        """Zero-count products in product_breakdown have all required keys set to zero."""
        from execution.collectors.armorcode_exploitable_collector import collect_exploitable_metrics

        name_to_id = {"Eclipse": "1", "ZeroProduct": "2"}
        critical_counts = {"1": 3}
        high_counts: dict[str, int] = {}
        medium_counts: dict[str, int] = {}

        with (
            patch(
                "execution.collectors.armorcode_exploitable_collector._get_products_by_hierarchy",
                return_value=name_to_id,
            ),
            patch(
                "execution.collectors.armorcode_exploitable_collector._count_by_severity",
                side_effect=[critical_counts, high_counts, medium_counts],
            ),
            patch("execution.collectors.armorcode_exploitable_collector.get_config") as mock_cfg,
        ):
            mock_cfg.return_value.get_optional_env.return_value = "test-hierarchy"
            result = collect_exploitable_metrics()

        zero_product = result["metrics"]["product_breakdown"]["ZeroProduct"]
        assert zero_product == {"critical": 0, "high": 0, "medium": 0, "total": 0}

    def test_totals_not_inflated_by_zero_products(self):
        """Severity totals reflect only actual findings, not zero-padded products."""
        from execution.collectors.armorcode_exploitable_collector import collect_exploitable_metrics

        name_to_id = {"Eclipse": "1", "Clean": "2", "AlsoClean": "3"}
        critical_counts = {"1": 2}
        high_counts = {"1": 5}
        medium_counts: dict[str, int] = {}

        with (
            patch(
                "execution.collectors.armorcode_exploitable_collector._get_products_by_hierarchy",
                return_value=name_to_id,
            ),
            patch(
                "execution.collectors.armorcode_exploitable_collector._count_by_severity",
                side_effect=[critical_counts, high_counts, medium_counts],
            ),
            patch("execution.collectors.armorcode_exploitable_collector.get_config") as mock_cfg,
        ):
            mock_cfg.return_value.get_optional_env.return_value = "test-hierarchy"
            result = collect_exploitable_metrics()

        sev = result["metrics"]["severity_breakdown"]
        assert sev["critical"] == 2
        assert sev["high"] == 5
        assert sev["medium"] == 0
        assert sev["total"] == 7
        assert result["metrics"]["current_total"] == 7
